
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model DriverVehicleAssignment
 * 
 */
export type DriverVehicleAssignment = $Result.DefaultSelection<Prisma.$DriverVehicleAssignmentPayload>
/**
 * Model Component
 * 
 */
export type Component = $Result.DefaultSelection<Prisma.$ComponentPayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model TripMetric
 * 
 */
export type TripMetric = $Result.DefaultSelection<Prisma.$TripMetricPayload>
/**
 * Model DriverEvaluation
 * 
 */
export type DriverEvaluation = $Result.DefaultSelection<Prisma.$DriverEvaluationPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model Maintenance
 * 
 */
export type Maintenance = $Result.DefaultSelection<Prisma.$MaintenancePayload>
/**
 * Model AIRecommendation
 * 
 */
export type AIRecommendation = $Result.DefaultSelection<Prisma.$AIRecommendationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driverVehicleAssignment`: Exposes CRUD operations for the **DriverVehicleAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriverVehicleAssignments
    * const driverVehicleAssignments = await prisma.driverVehicleAssignment.findMany()
    * ```
    */
  get driverVehicleAssignment(): Prisma.DriverVehicleAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.component`: Exposes CRUD operations for the **Component** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Components
    * const components = await prisma.component.findMany()
    * ```
    */
  get component(): Prisma.ComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tripMetric`: Exposes CRUD operations for the **TripMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripMetrics
    * const tripMetrics = await prisma.tripMetric.findMany()
    * ```
    */
  get tripMetric(): Prisma.TripMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driverEvaluation`: Exposes CRUD operations for the **DriverEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriverEvaluations
    * const driverEvaluations = await prisma.driverEvaluation.findMany()
    * ```
    */
  get driverEvaluation(): Prisma.DriverEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenance`: Exposes CRUD operations for the **Maintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenances
    * const maintenances = await prisma.maintenance.findMany()
    * ```
    */
  get maintenance(): Prisma.MaintenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIRecommendation`: Exposes CRUD operations for the **AIRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIRecommendations
    * const aIRecommendations = await prisma.aIRecommendation.findMany()
    * ```
    */
  get aIRecommendation(): Prisma.AIRecommendationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    Driver: 'Driver',
    Vehicle: 'Vehicle',
    DriverVehicleAssignment: 'DriverVehicleAssignment',
    Component: 'Component',
    Trip: 'Trip',
    TripMetric: 'TripMetric',
    DriverEvaluation: 'DriverEvaluation',
    Alert: 'Alert',
    Maintenance: 'Maintenance',
    AIRecommendation: 'AIRecommendation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "refreshToken" | "driver" | "vehicle" | "driverVehicleAssignment" | "component" | "trip" | "tripMetric" | "driverEvaluation" | "alert" | "maintenance" | "aIRecommendation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      DriverVehicleAssignment: {
        payload: Prisma.$DriverVehicleAssignmentPayload<ExtArgs>
        fields: Prisma.DriverVehicleAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverVehicleAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverVehicleAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload>
          }
          findFirst: {
            args: Prisma.DriverVehicleAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverVehicleAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload>
          }
          findMany: {
            args: Prisma.DriverVehicleAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload>[]
          }
          create: {
            args: Prisma.DriverVehicleAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload>
          }
          createMany: {
            args: Prisma.DriverVehicleAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DriverVehicleAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload>
          }
          update: {
            args: Prisma.DriverVehicleAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.DriverVehicleAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverVehicleAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverVehicleAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVehicleAssignmentPayload>
          }
          aggregate: {
            args: Prisma.DriverVehicleAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverVehicleAssignment>
          }
          groupBy: {
            args: Prisma.DriverVehicleAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverVehicleAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverVehicleAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<DriverVehicleAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Component: {
        payload: Prisma.$ComponentPayload<ExtArgs>
        fields: Prisma.ComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findFirst: {
            args: Prisma.ComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findMany: {
            args: Prisma.ComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          create: {
            args: Prisma.ComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          createMany: {
            args: Prisma.ComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          update: {
            args: Prisma.ComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          deleteMany: {
            args: Prisma.ComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          aggregate: {
            args: Prisma.ComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponent>
          }
          groupBy: {
            args: Prisma.ComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      TripMetric: {
        payload: Prisma.$TripMetricPayload<ExtArgs>
        fields: Prisma.TripMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload>
          }
          findFirst: {
            args: Prisma.TripMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload>
          }
          findMany: {
            args: Prisma.TripMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload>[]
          }
          create: {
            args: Prisma.TripMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload>
          }
          createMany: {
            args: Prisma.TripMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TripMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload>
          }
          update: {
            args: Prisma.TripMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload>
          }
          deleteMany: {
            args: Prisma.TripMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TripMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripMetricPayload>
          }
          aggregate: {
            args: Prisma.TripMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripMetric>
          }
          groupBy: {
            args: Prisma.TripMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripMetricCountArgs<ExtArgs>
            result: $Utils.Optional<TripMetricCountAggregateOutputType> | number
          }
        }
      }
      DriverEvaluation: {
        payload: Prisma.$DriverEvaluationPayload<ExtArgs>
        fields: Prisma.DriverEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload>
          }
          findFirst: {
            args: Prisma.DriverEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload>
          }
          findMany: {
            args: Prisma.DriverEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload>[]
          }
          create: {
            args: Prisma.DriverEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload>
          }
          createMany: {
            args: Prisma.DriverEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DriverEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload>
          }
          update: {
            args: Prisma.DriverEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.DriverEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DriverEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverEvaluationPayload>
          }
          aggregate: {
            args: Prisma.DriverEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverEvaluation>
          }
          groupBy: {
            args: Prisma.DriverEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<DriverEvaluationCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      Maintenance: {
        payload: Prisma.$MaintenancePayload<ExtArgs>
        fields: Prisma.MaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findFirst: {
            args: Prisma.MaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findMany: {
            args: Prisma.MaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          create: {
            args: Prisma.MaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          createMany: {
            args: Prisma.MaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          update: {
            args: Prisma.MaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          aggregate: {
            args: Prisma.MaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance>
          }
          groupBy: {
            args: Prisma.MaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceCountAggregateOutputType> | number
          }
        }
      }
      AIRecommendation: {
        payload: Prisma.$AIRecommendationPayload<ExtArgs>
        fields: Prisma.AIRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          findFirst: {
            args: Prisma.AIRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          findMany: {
            args: Prisma.AIRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>[]
          }
          create: {
            args: Prisma.AIRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          createMany: {
            args: Prisma.AIRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AIRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          update: {
            args: Prisma.AIRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.AIRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIRecommendationPayload>
          }
          aggregate: {
            args: Prisma.AIRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIRecommendation>
          }
          groupBy: {
            args: Prisma.AIRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<AIRecommendationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    driver?: DriverOmit
    vehicle?: VehicleOmit
    driverVehicleAssignment?: DriverVehicleAssignmentOmit
    component?: ComponentOmit
    trip?: TripOmit
    tripMetric?: TripMetricOmit
    driverEvaluation?: DriverEvaluationOmit
    alert?: AlertOmit
    maintenance?: MaintenanceOmit
    aIRecommendation?: AIRecommendationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }


  /**
   * Count Type DriverCountOutputType
   */

  export type DriverCountOutputType = {
    aiRecommendations: number
    evaluations: number
    assignedVehicles: number
    trips: number
  }

  export type DriverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiRecommendations?: boolean | DriverCountOutputTypeCountAiRecommendationsArgs
    evaluations?: boolean | DriverCountOutputTypeCountEvaluationsArgs
    assignedVehicles?: boolean | DriverCountOutputTypeCountAssignedVehiclesArgs
    trips?: boolean | DriverCountOutputTypeCountTripsArgs
  }

  // Custom InputTypes
  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountAiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverEvaluationWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountAssignedVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverVehicleAssignmentWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    aiRecommendations: number
    alerts: number
    components: number
    assignedDrivers: number
    maintenance: number
    trips: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiRecommendations?: boolean | VehicleCountOutputTypeCountAiRecommendationsArgs
    alerts?: boolean | VehicleCountOutputTypeCountAlertsArgs
    components?: boolean | VehicleCountOutputTypeCountComponentsArgs
    assignedDrivers?: boolean | VehicleCountOutputTypeCountAssignedDriversArgs
    maintenance?: boolean | VehicleCountOutputTypeCountMaintenanceArgs
    trips?: boolean | VehicleCountOutputTypeCountTripsArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountAiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountAssignedDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverVehicleAssignmentWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }


  /**
   * Count Type ComponentCountOutputType
   */

  export type ComponentCountOutputType = {
    aiRecommendations: number
    alerts: number
    maintenance: number
  }

  export type ComponentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiRecommendations?: boolean | ComponentCountOutputTypeCountAiRecommendationsArgs
    alerts?: boolean | ComponentCountOutputTypeCountAlertsArgs
    maintenance?: boolean | ComponentCountOutputTypeCountMaintenanceArgs
  }

  // Custom InputTypes
  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComponentCountOutputType
     */
    select?: ComponentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeCountAiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
  }

  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * ComponentCountOutputType without action
   */
  export type ComponentCountOutputTypeCountMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }


  /**
   * Count Type TripCountOutputType
   */

  export type TripCountOutputType = {
    aiRecommendations: number
    metrics: number
  }

  export type TripCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiRecommendations?: boolean | TripCountOutputTypeCountAiRecommendationsArgs
    metrics?: boolean | TripCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCountOutputType
     */
    select?: TripCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountAiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMetricWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | User$driverArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | User$driverArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      driver: Prisma.$DriverPayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends User$driverArgs<ExtArgs> = {}>(args?: Subset<T, User$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.driver
   */
  export type User$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    expiresAt: Date | null
    userId: string | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    expiresAt: Date | null
    userId: string | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    expiresAt: number
    userId: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    expiresAt: Date
    userId: string
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>



  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiresAt" | "userId", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      expiresAt: Date
      userId: string
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    driverScore: number | null
  }

  export type DriverSumAggregateOutputType = {
    driverScore: number | null
  }

  export type DriverMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    licenseNumber: string | null
    licenseExpiry: Date | null
    phoneNumber: string | null
    driverScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    licenseNumber: string | null
    licenseExpiry: Date | null
    phoneNumber: string | null
    driverScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    licenseNumber: number
    licenseExpiry: number
    phoneNumber: number
    driverScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    driverScore?: true
  }

  export type DriverSumAggregateInputType = {
    driverScore?: true
  }

  export type DriverMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    licenseNumber?: true
    licenseExpiry?: true
    phoneNumber?: true
    driverScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    licenseNumber?: true
    licenseExpiry?: true
    phoneNumber?: true
    driverScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    licenseNumber?: true
    licenseExpiry?: true
    phoneNumber?: true
    driverScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    id: string
    userId: string
    name: string
    licenseNumber: string
    licenseExpiry: Date
    phoneNumber: string
    driverScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    phoneNumber?: boolean
    driverScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiRecommendations?: boolean | Driver$aiRecommendationsArgs<ExtArgs>
    evaluations?: boolean | Driver$evaluationsArgs<ExtArgs>
    assignedVehicles?: boolean | Driver$assignedVehiclesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    trips?: boolean | Driver$tripsArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>



  export type DriverSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    licenseNumber?: boolean
    licenseExpiry?: boolean
    phoneNumber?: boolean
    driverScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DriverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "licenseNumber" | "licenseExpiry" | "phoneNumber" | "driverScore" | "createdAt" | "updatedAt", ExtArgs["result"]["driver"]>
  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiRecommendations?: boolean | Driver$aiRecommendationsArgs<ExtArgs>
    evaluations?: boolean | Driver$evaluationsArgs<ExtArgs>
    assignedVehicles?: boolean | Driver$assignedVehiclesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    trips?: boolean | Driver$tripsArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      aiRecommendations: Prisma.$AIRecommendationPayload<ExtArgs>[]
      evaluations: Prisma.$DriverEvaluationPayload<ExtArgs>[]
      assignedVehicles: Prisma.$DriverVehicleAssignmentPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      trips: Prisma.$TripPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      licenseNumber: string
      licenseExpiry: Date
      phoneNumber: string
      driverScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiRecommendations<T extends Driver$aiRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$aiRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaluations<T extends Driver$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedVehicles<T extends Driver$assignedVehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Driver$assignedVehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trips<T extends Driver$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */
  interface DriverFieldRefs {
    readonly id: FieldRef<"Driver", 'String'>
    readonly userId: FieldRef<"Driver", 'String'>
    readonly name: FieldRef<"Driver", 'String'>
    readonly licenseNumber: FieldRef<"Driver", 'String'>
    readonly licenseExpiry: FieldRef<"Driver", 'DateTime'>
    readonly phoneNumber: FieldRef<"Driver", 'String'>
    readonly driverScore: FieldRef<"Driver", 'Float'>
    readonly createdAt: FieldRef<"Driver", 'DateTime'>
    readonly updatedAt: FieldRef<"Driver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to delete.
     */
    limit?: number
  }

  /**
   * Driver.aiRecommendations
   */
  export type Driver$aiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    cursor?: AIRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * Driver.evaluations
   */
  export type Driver$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    where?: DriverEvaluationWhereInput
    orderBy?: DriverEvaluationOrderByWithRelationInput | DriverEvaluationOrderByWithRelationInput[]
    cursor?: DriverEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverEvaluationScalarFieldEnum | DriverEvaluationScalarFieldEnum[]
  }

  /**
   * Driver.assignedVehicles
   */
  export type Driver$assignedVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    where?: DriverVehicleAssignmentWhereInput
    orderBy?: DriverVehicleAssignmentOrderByWithRelationInput | DriverVehicleAssignmentOrderByWithRelationInput[]
    cursor?: DriverVehicleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverVehicleAssignmentScalarFieldEnum | DriverVehicleAssignmentScalarFieldEnum[]
  }

  /**
   * Driver.trips
   */
  export type Driver$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    year: number | null
    fuelLevel: number | null
  }

  export type VehicleSumAggregateOutputType = {
    year: number | null
    fuelLevel: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    model: string | null
    year: number | null
    plateNumber: string | null
    status: string | null
    fuelType: string | null
    fuelLevel: number | null
    insuranceExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    model: string | null
    year: number | null
    plateNumber: string | null
    status: string | null
    fuelType: string | null
    fuelLevel: number | null
    insuranceExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    model: number
    year: number
    plateNumber: number
    status: number
    fuelType: number
    fuelLevel: number
    insuranceExpiry: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    year?: true
    fuelLevel?: true
  }

  export type VehicleSumAggregateInputType = {
    year?: true
    fuelLevel?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    model?: true
    year?: true
    plateNumber?: true
    status?: true
    fuelType?: true
    fuelLevel?: true
    insuranceExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    model?: true
    year?: true
    plateNumber?: true
    status?: true
    fuelType?: true
    fuelLevel?: true
    insuranceExpiry?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    model?: true
    year?: true
    plateNumber?: true
    status?: true
    fuelType?: true
    fuelLevel?: true
    insuranceExpiry?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date
    createdAt: Date
    updatedAt: Date
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model?: boolean
    year?: boolean
    plateNumber?: boolean
    status?: boolean
    fuelType?: boolean
    fuelLevel?: boolean
    insuranceExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiRecommendations?: boolean | Vehicle$aiRecommendationsArgs<ExtArgs>
    alerts?: boolean | Vehicle$alertsArgs<ExtArgs>
    components?: boolean | Vehicle$componentsArgs<ExtArgs>
    assignedDrivers?: boolean | Vehicle$assignedDriversArgs<ExtArgs>
    maintenance?: boolean | Vehicle$maintenanceArgs<ExtArgs>
    trips?: boolean | Vehicle$tripsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>



  export type VehicleSelectScalar = {
    id?: boolean
    model?: boolean
    year?: boolean
    plateNumber?: boolean
    status?: boolean
    fuelType?: boolean
    fuelLevel?: boolean
    insuranceExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "model" | "year" | "plateNumber" | "status" | "fuelType" | "fuelLevel" | "insuranceExpiry" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiRecommendations?: boolean | Vehicle$aiRecommendationsArgs<ExtArgs>
    alerts?: boolean | Vehicle$alertsArgs<ExtArgs>
    components?: boolean | Vehicle$componentsArgs<ExtArgs>
    assignedDrivers?: boolean | Vehicle$assignedDriversArgs<ExtArgs>
    maintenance?: boolean | Vehicle$maintenanceArgs<ExtArgs>
    trips?: boolean | Vehicle$tripsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      aiRecommendations: Prisma.$AIRecommendationPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      components: Prisma.$ComponentPayload<ExtArgs>[]
      assignedDrivers: Prisma.$DriverVehicleAssignmentPayload<ExtArgs>[]
      maintenance: Prisma.$MaintenancePayload<ExtArgs>[]
      trips: Prisma.$TripPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      model: string
      year: number
      plateNumber: string
      status: string
      fuelType: string
      fuelLevel: number
      insuranceExpiry: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiRecommendations<T extends Vehicle$aiRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$aiRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    alerts<T extends Vehicle$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    components<T extends Vehicle$componentsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedDrivers<T extends Vehicle$assignedDriversArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$assignedDriversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenance<T extends Vehicle$maintenanceArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$maintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trips<T extends Vehicle$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly model: FieldRef<"Vehicle", 'String'>
    readonly year: FieldRef<"Vehicle", 'Int'>
    readonly plateNumber: FieldRef<"Vehicle", 'String'>
    readonly status: FieldRef<"Vehicle", 'String'>
    readonly fuelType: FieldRef<"Vehicle", 'String'>
    readonly fuelLevel: FieldRef<"Vehicle", 'Float'>
    readonly insuranceExpiry: FieldRef<"Vehicle", 'DateTime'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle.aiRecommendations
   */
  export type Vehicle$aiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    cursor?: AIRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * Vehicle.alerts
   */
  export type Vehicle$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Vehicle.components
   */
  export type Vehicle$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    cursor?: ComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Vehicle.assignedDrivers
   */
  export type Vehicle$assignedDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    where?: DriverVehicleAssignmentWhereInput
    orderBy?: DriverVehicleAssignmentOrderByWithRelationInput | DriverVehicleAssignmentOrderByWithRelationInput[]
    cursor?: DriverVehicleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverVehicleAssignmentScalarFieldEnum | DriverVehicleAssignmentScalarFieldEnum[]
  }

  /**
   * Vehicle.maintenance
   */
  export type Vehicle$maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Vehicle.trips
   */
  export type Vehicle$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model DriverVehicleAssignment
   */

  export type AggregateDriverVehicleAssignment = {
    _count: DriverVehicleAssignmentCountAggregateOutputType | null
    _min: DriverVehicleAssignmentMinAggregateOutputType | null
    _max: DriverVehicleAssignmentMaxAggregateOutputType | null
  }

  export type DriverVehicleAssignmentMinAggregateOutputType = {
    driverId: string | null
    vehicleId: string | null
    assignedAt: Date | null
  }

  export type DriverVehicleAssignmentMaxAggregateOutputType = {
    driverId: string | null
    vehicleId: string | null
    assignedAt: Date | null
  }

  export type DriverVehicleAssignmentCountAggregateOutputType = {
    driverId: number
    vehicleId: number
    assignedAt: number
    _all: number
  }


  export type DriverVehicleAssignmentMinAggregateInputType = {
    driverId?: true
    vehicleId?: true
    assignedAt?: true
  }

  export type DriverVehicleAssignmentMaxAggregateInputType = {
    driverId?: true
    vehicleId?: true
    assignedAt?: true
  }

  export type DriverVehicleAssignmentCountAggregateInputType = {
    driverId?: true
    vehicleId?: true
    assignedAt?: true
    _all?: true
  }

  export type DriverVehicleAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverVehicleAssignment to aggregate.
     */
    where?: DriverVehicleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVehicleAssignments to fetch.
     */
    orderBy?: DriverVehicleAssignmentOrderByWithRelationInput | DriverVehicleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverVehicleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVehicleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVehicleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriverVehicleAssignments
    **/
    _count?: true | DriverVehicleAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverVehicleAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverVehicleAssignmentMaxAggregateInputType
  }

  export type GetDriverVehicleAssignmentAggregateType<T extends DriverVehicleAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverVehicleAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverVehicleAssignment[P]>
      : GetScalarType<T[P], AggregateDriverVehicleAssignment[P]>
  }




  export type DriverVehicleAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverVehicleAssignmentWhereInput
    orderBy?: DriverVehicleAssignmentOrderByWithAggregationInput | DriverVehicleAssignmentOrderByWithAggregationInput[]
    by: DriverVehicleAssignmentScalarFieldEnum[] | DriverVehicleAssignmentScalarFieldEnum
    having?: DriverVehicleAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverVehicleAssignmentCountAggregateInputType | true
    _min?: DriverVehicleAssignmentMinAggregateInputType
    _max?: DriverVehicleAssignmentMaxAggregateInputType
  }

  export type DriverVehicleAssignmentGroupByOutputType = {
    driverId: string
    vehicleId: string
    assignedAt: Date
    _count: DriverVehicleAssignmentCountAggregateOutputType | null
    _min: DriverVehicleAssignmentMinAggregateOutputType | null
    _max: DriverVehicleAssignmentMaxAggregateOutputType | null
  }

  type GetDriverVehicleAssignmentGroupByPayload<T extends DriverVehicleAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverVehicleAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverVehicleAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverVehicleAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], DriverVehicleAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type DriverVehicleAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    driverId?: boolean
    vehicleId?: boolean
    assignedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverVehicleAssignment"]>



  export type DriverVehicleAssignmentSelectScalar = {
    driverId?: boolean
    vehicleId?: boolean
    assignedAt?: boolean
  }

  export type DriverVehicleAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"driverId" | "vehicleId" | "assignedAt", ExtArgs["result"]["driverVehicleAssignment"]>
  export type DriverVehicleAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $DriverVehicleAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriverVehicleAssignment"
    objects: {
      driver: Prisma.$DriverPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      driverId: string
      vehicleId: string
      assignedAt: Date
    }, ExtArgs["result"]["driverVehicleAssignment"]>
    composites: {}
  }

  type DriverVehicleAssignmentGetPayload<S extends boolean | null | undefined | DriverVehicleAssignmentDefaultArgs> = $Result.GetResult<Prisma.$DriverVehicleAssignmentPayload, S>

  type DriverVehicleAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverVehicleAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverVehicleAssignmentCountAggregateInputType | true
    }

  export interface DriverVehicleAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriverVehicleAssignment'], meta: { name: 'DriverVehicleAssignment' } }
    /**
     * Find zero or one DriverVehicleAssignment that matches the filter.
     * @param {DriverVehicleAssignmentFindUniqueArgs} args - Arguments to find a DriverVehicleAssignment
     * @example
     * // Get one DriverVehicleAssignment
     * const driverVehicleAssignment = await prisma.driverVehicleAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverVehicleAssignmentFindUniqueArgs>(args: SelectSubset<T, DriverVehicleAssignmentFindUniqueArgs<ExtArgs>>): Prisma__DriverVehicleAssignmentClient<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DriverVehicleAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverVehicleAssignmentFindUniqueOrThrowArgs} args - Arguments to find a DriverVehicleAssignment
     * @example
     * // Get one DriverVehicleAssignment
     * const driverVehicleAssignment = await prisma.driverVehicleAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverVehicleAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverVehicleAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverVehicleAssignmentClient<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverVehicleAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleAssignmentFindFirstArgs} args - Arguments to find a DriverVehicleAssignment
     * @example
     * // Get one DriverVehicleAssignment
     * const driverVehicleAssignment = await prisma.driverVehicleAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverVehicleAssignmentFindFirstArgs>(args?: SelectSubset<T, DriverVehicleAssignmentFindFirstArgs<ExtArgs>>): Prisma__DriverVehicleAssignmentClient<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverVehicleAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleAssignmentFindFirstOrThrowArgs} args - Arguments to find a DriverVehicleAssignment
     * @example
     * // Get one DriverVehicleAssignment
     * const driverVehicleAssignment = await prisma.driverVehicleAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverVehicleAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverVehicleAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverVehicleAssignmentClient<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DriverVehicleAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverVehicleAssignments
     * const driverVehicleAssignments = await prisma.driverVehicleAssignment.findMany()
     * 
     * // Get first 10 DriverVehicleAssignments
     * const driverVehicleAssignments = await prisma.driverVehicleAssignment.findMany({ take: 10 })
     * 
     * // Only select the `driverId`
     * const driverVehicleAssignmentWithDriverIdOnly = await prisma.driverVehicleAssignment.findMany({ select: { driverId: true } })
     * 
     */
    findMany<T extends DriverVehicleAssignmentFindManyArgs>(args?: SelectSubset<T, DriverVehicleAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DriverVehicleAssignment.
     * @param {DriverVehicleAssignmentCreateArgs} args - Arguments to create a DriverVehicleAssignment.
     * @example
     * // Create one DriverVehicleAssignment
     * const DriverVehicleAssignment = await prisma.driverVehicleAssignment.create({
     *   data: {
     *     // ... data to create a DriverVehicleAssignment
     *   }
     * })
     * 
     */
    create<T extends DriverVehicleAssignmentCreateArgs>(args: SelectSubset<T, DriverVehicleAssignmentCreateArgs<ExtArgs>>): Prisma__DriverVehicleAssignmentClient<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DriverVehicleAssignments.
     * @param {DriverVehicleAssignmentCreateManyArgs} args - Arguments to create many DriverVehicleAssignments.
     * @example
     * // Create many DriverVehicleAssignments
     * const driverVehicleAssignment = await prisma.driverVehicleAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverVehicleAssignmentCreateManyArgs>(args?: SelectSubset<T, DriverVehicleAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DriverVehicleAssignment.
     * @param {DriverVehicleAssignmentDeleteArgs} args - Arguments to delete one DriverVehicleAssignment.
     * @example
     * // Delete one DriverVehicleAssignment
     * const DriverVehicleAssignment = await prisma.driverVehicleAssignment.delete({
     *   where: {
     *     // ... filter to delete one DriverVehicleAssignment
     *   }
     * })
     * 
     */
    delete<T extends DriverVehicleAssignmentDeleteArgs>(args: SelectSubset<T, DriverVehicleAssignmentDeleteArgs<ExtArgs>>): Prisma__DriverVehicleAssignmentClient<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DriverVehicleAssignment.
     * @param {DriverVehicleAssignmentUpdateArgs} args - Arguments to update one DriverVehicleAssignment.
     * @example
     * // Update one DriverVehicleAssignment
     * const driverVehicleAssignment = await prisma.driverVehicleAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverVehicleAssignmentUpdateArgs>(args: SelectSubset<T, DriverVehicleAssignmentUpdateArgs<ExtArgs>>): Prisma__DriverVehicleAssignmentClient<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DriverVehicleAssignments.
     * @param {DriverVehicleAssignmentDeleteManyArgs} args - Arguments to filter DriverVehicleAssignments to delete.
     * @example
     * // Delete a few DriverVehicleAssignments
     * const { count } = await prisma.driverVehicleAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverVehicleAssignmentDeleteManyArgs>(args?: SelectSubset<T, DriverVehicleAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverVehicleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverVehicleAssignments
     * const driverVehicleAssignment = await prisma.driverVehicleAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverVehicleAssignmentUpdateManyArgs>(args: SelectSubset<T, DriverVehicleAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DriverVehicleAssignment.
     * @param {DriverVehicleAssignmentUpsertArgs} args - Arguments to update or create a DriverVehicleAssignment.
     * @example
     * // Update or create a DriverVehicleAssignment
     * const driverVehicleAssignment = await prisma.driverVehicleAssignment.upsert({
     *   create: {
     *     // ... data to create a DriverVehicleAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverVehicleAssignment we want to update
     *   }
     * })
     */
    upsert<T extends DriverVehicleAssignmentUpsertArgs>(args: SelectSubset<T, DriverVehicleAssignmentUpsertArgs<ExtArgs>>): Prisma__DriverVehicleAssignmentClient<$Result.GetResult<Prisma.$DriverVehicleAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DriverVehicleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleAssignmentCountArgs} args - Arguments to filter DriverVehicleAssignments to count.
     * @example
     * // Count the number of DriverVehicleAssignments
     * const count = await prisma.driverVehicleAssignment.count({
     *   where: {
     *     // ... the filter for the DriverVehicleAssignments we want to count
     *   }
     * })
    **/
    count<T extends DriverVehicleAssignmentCountArgs>(
      args?: Subset<T, DriverVehicleAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverVehicleAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriverVehicleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverVehicleAssignmentAggregateArgs>(args: Subset<T, DriverVehicleAssignmentAggregateArgs>): Prisma.PrismaPromise<GetDriverVehicleAssignmentAggregateType<T>>

    /**
     * Group by DriverVehicleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVehicleAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverVehicleAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverVehicleAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: DriverVehicleAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverVehicleAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverVehicleAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriverVehicleAssignment model
   */
  readonly fields: DriverVehicleAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverVehicleAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverVehicleAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriverVehicleAssignment model
   */
  interface DriverVehicleAssignmentFieldRefs {
    readonly driverId: FieldRef<"DriverVehicleAssignment", 'String'>
    readonly vehicleId: FieldRef<"DriverVehicleAssignment", 'String'>
    readonly assignedAt: FieldRef<"DriverVehicleAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DriverVehicleAssignment findUnique
   */
  export type DriverVehicleAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicleAssignment to fetch.
     */
    where: DriverVehicleAssignmentWhereUniqueInput
  }

  /**
   * DriverVehicleAssignment findUniqueOrThrow
   */
  export type DriverVehicleAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicleAssignment to fetch.
     */
    where: DriverVehicleAssignmentWhereUniqueInput
  }

  /**
   * DriverVehicleAssignment findFirst
   */
  export type DriverVehicleAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicleAssignment to fetch.
     */
    where?: DriverVehicleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVehicleAssignments to fetch.
     */
    orderBy?: DriverVehicleAssignmentOrderByWithRelationInput | DriverVehicleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverVehicleAssignments.
     */
    cursor?: DriverVehicleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVehicleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVehicleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverVehicleAssignments.
     */
    distinct?: DriverVehicleAssignmentScalarFieldEnum | DriverVehicleAssignmentScalarFieldEnum[]
  }

  /**
   * DriverVehicleAssignment findFirstOrThrow
   */
  export type DriverVehicleAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicleAssignment to fetch.
     */
    where?: DriverVehicleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVehicleAssignments to fetch.
     */
    orderBy?: DriverVehicleAssignmentOrderByWithRelationInput | DriverVehicleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverVehicleAssignments.
     */
    cursor?: DriverVehicleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVehicleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVehicleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverVehicleAssignments.
     */
    distinct?: DriverVehicleAssignmentScalarFieldEnum | DriverVehicleAssignmentScalarFieldEnum[]
  }

  /**
   * DriverVehicleAssignment findMany
   */
  export type DriverVehicleAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which DriverVehicleAssignments to fetch.
     */
    where?: DriverVehicleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVehicleAssignments to fetch.
     */
    orderBy?: DriverVehicleAssignmentOrderByWithRelationInput | DriverVehicleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriverVehicleAssignments.
     */
    cursor?: DriverVehicleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVehicleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVehicleAssignments.
     */
    skip?: number
    distinct?: DriverVehicleAssignmentScalarFieldEnum | DriverVehicleAssignmentScalarFieldEnum[]
  }

  /**
   * DriverVehicleAssignment create
   */
  export type DriverVehicleAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DriverVehicleAssignment.
     */
    data: XOR<DriverVehicleAssignmentCreateInput, DriverVehicleAssignmentUncheckedCreateInput>
  }

  /**
   * DriverVehicleAssignment createMany
   */
  export type DriverVehicleAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriverVehicleAssignments.
     */
    data: DriverVehicleAssignmentCreateManyInput | DriverVehicleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriverVehicleAssignment update
   */
  export type DriverVehicleAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DriverVehicleAssignment.
     */
    data: XOR<DriverVehicleAssignmentUpdateInput, DriverVehicleAssignmentUncheckedUpdateInput>
    /**
     * Choose, which DriverVehicleAssignment to update.
     */
    where: DriverVehicleAssignmentWhereUniqueInput
  }

  /**
   * DriverVehicleAssignment updateMany
   */
  export type DriverVehicleAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriverVehicleAssignments.
     */
    data: XOR<DriverVehicleAssignmentUpdateManyMutationInput, DriverVehicleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which DriverVehicleAssignments to update
     */
    where?: DriverVehicleAssignmentWhereInput
    /**
     * Limit how many DriverVehicleAssignments to update.
     */
    limit?: number
  }

  /**
   * DriverVehicleAssignment upsert
   */
  export type DriverVehicleAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DriverVehicleAssignment to update in case it exists.
     */
    where: DriverVehicleAssignmentWhereUniqueInput
    /**
     * In case the DriverVehicleAssignment found by the `where` argument doesn't exist, create a new DriverVehicleAssignment with this data.
     */
    create: XOR<DriverVehicleAssignmentCreateInput, DriverVehicleAssignmentUncheckedCreateInput>
    /**
     * In case the DriverVehicleAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverVehicleAssignmentUpdateInput, DriverVehicleAssignmentUncheckedUpdateInput>
  }

  /**
   * DriverVehicleAssignment delete
   */
  export type DriverVehicleAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
    /**
     * Filter which DriverVehicleAssignment to delete.
     */
    where: DriverVehicleAssignmentWhereUniqueInput
  }

  /**
   * DriverVehicleAssignment deleteMany
   */
  export type DriverVehicleAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverVehicleAssignments to delete
     */
    where?: DriverVehicleAssignmentWhereInput
    /**
     * Limit how many DriverVehicleAssignments to delete.
     */
    limit?: number
  }

  /**
   * DriverVehicleAssignment without action
   */
  export type DriverVehicleAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVehicleAssignment
     */
    select?: DriverVehicleAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVehicleAssignment
     */
    omit?: DriverVehicleAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVehicleAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Component
   */

  export type AggregateComponent = {
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  export type ComponentAvgAggregateOutputType = {
    healthScore: number | null
    expectedLifespan: number | null
  }

  export type ComponentSumAggregateOutputType = {
    healthScore: number | null
    expectedLifespan: number | null
  }

  export type ComponentMinAggregateOutputType = {
    id: string | null
    vehicleId: string | null
    componentType: string | null
    name: string | null
    status: string | null
    healthScore: number | null
    expectedLifespan: number | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentMaxAggregateOutputType = {
    id: string | null
    vehicleId: string | null
    componentType: string | null
    name: string | null
    status: string | null
    healthScore: number | null
    expectedLifespan: number | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComponentCountAggregateOutputType = {
    id: number
    vehicleId: number
    componentType: number
    name: number
    status: number
    healthScore: number
    expectedLifespan: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComponentAvgAggregateInputType = {
    healthScore?: true
    expectedLifespan?: true
  }

  export type ComponentSumAggregateInputType = {
    healthScore?: true
    expectedLifespan?: true
  }

  export type ComponentMinAggregateInputType = {
    id?: true
    vehicleId?: true
    componentType?: true
    name?: true
    status?: true
    healthScore?: true
    expectedLifespan?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentMaxAggregateInputType = {
    id?: true
    vehicleId?: true
    componentType?: true
    name?: true
    status?: true
    healthScore?: true
    expectedLifespan?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComponentCountAggregateInputType = {
    id?: true
    vehicleId?: true
    componentType?: true
    name?: true
    status?: true
    healthScore?: true
    expectedLifespan?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Component to aggregate.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Components
    **/
    _count?: true | ComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentMaxAggregateInputType
  }

  export type GetComponentAggregateType<T extends ComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent[P]>
      : GetScalarType<T[P], AggregateComponent[P]>
  }




  export type ComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithAggregationInput | ComponentOrderByWithAggregationInput[]
    by: ComponentScalarFieldEnum[] | ComponentScalarFieldEnum
    having?: ComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentCountAggregateInputType | true
    _avg?: ComponentAvgAggregateInputType
    _sum?: ComponentSumAggregateInputType
    _min?: ComponentMinAggregateInputType
    _max?: ComponentMaxAggregateInputType
  }

  export type ComponentGroupByOutputType = {
    id: string
    vehicleId: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  type GetComponentGroupByPayload<T extends ComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentGroupByOutputType[P]>
        }
      >
    >


  export type ComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleId?: boolean
    componentType?: boolean
    name?: boolean
    status?: boolean
    healthScore?: boolean
    expectedLifespan?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiRecommendations?: boolean | Component$aiRecommendationsArgs<ExtArgs>
    alerts?: boolean | Component$alertsArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    maintenance?: boolean | Component$maintenanceArgs<ExtArgs>
    _count?: boolean | ComponentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>



  export type ComponentSelectScalar = {
    id?: boolean
    vehicleId?: boolean
    componentType?: boolean
    name?: boolean
    status?: boolean
    healthScore?: boolean
    expectedLifespan?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicleId" | "componentType" | "name" | "status" | "healthScore" | "expectedLifespan" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["component"]>
  export type ComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiRecommendations?: boolean | Component$aiRecommendationsArgs<ExtArgs>
    alerts?: boolean | Component$alertsArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    maintenance?: boolean | Component$maintenanceArgs<ExtArgs>
    _count?: boolean | ComponentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Component"
    objects: {
      aiRecommendations: Prisma.$AIRecommendationPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      vehicle: Prisma.$VehiclePayload<ExtArgs>
      maintenance: Prisma.$MaintenancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicleId: string
      componentType: string
      name: string
      status: string
      healthScore: number
      expectedLifespan: number
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["component"]>
    composites: {}
  }

  type ComponentGetPayload<S extends boolean | null | undefined | ComponentDefaultArgs> = $Result.GetResult<Prisma.$ComponentPayload, S>

  type ComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComponentCountAggregateInputType | true
    }

  export interface ComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Component'], meta: { name: 'Component' } }
    /**
     * Find zero or one Component that matches the filter.
     * @param {ComponentFindUniqueArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentFindUniqueArgs>(args: SelectSubset<T, ComponentFindUniqueArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Component that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComponentFindUniqueOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Component that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentFindFirstArgs>(args?: SelectSubset<T, ComponentFindFirstArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Component that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Components
     * const components = await prisma.component.findMany()
     * 
     * // Get first 10 Components
     * const components = await prisma.component.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentWithIdOnly = await prisma.component.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComponentFindManyArgs>(args?: SelectSubset<T, ComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Component.
     * @param {ComponentCreateArgs} args - Arguments to create a Component.
     * @example
     * // Create one Component
     * const Component = await prisma.component.create({
     *   data: {
     *     // ... data to create a Component
     *   }
     * })
     * 
     */
    create<T extends ComponentCreateArgs>(args: SelectSubset<T, ComponentCreateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Components.
     * @param {ComponentCreateManyArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentCreateManyArgs>(args?: SelectSubset<T, ComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Component.
     * @param {ComponentDeleteArgs} args - Arguments to delete one Component.
     * @example
     * // Delete one Component
     * const Component = await prisma.component.delete({
     *   where: {
     *     // ... filter to delete one Component
     *   }
     * })
     * 
     */
    delete<T extends ComponentDeleteArgs>(args: SelectSubset<T, ComponentDeleteArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Component.
     * @param {ComponentUpdateArgs} args - Arguments to update one Component.
     * @example
     * // Update one Component
     * const component = await prisma.component.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentUpdateArgs>(args: SelectSubset<T, ComponentUpdateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Components.
     * @param {ComponentDeleteManyArgs} args - Arguments to filter Components to delete.
     * @example
     * // Delete a few Components
     * const { count } = await prisma.component.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentDeleteManyArgs>(args?: SelectSubset<T, ComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentUpdateManyArgs>(args: SelectSubset<T, ComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Component.
     * @param {ComponentUpsertArgs} args - Arguments to update or create a Component.
     * @example
     * // Update or create a Component
     * const component = await prisma.component.upsert({
     *   create: {
     *     // ... data to create a Component
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component we want to update
     *   }
     * })
     */
    upsert<T extends ComponentUpsertArgs>(args: SelectSubset<T, ComponentUpsertArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentCountArgs} args - Arguments to filter Components to count.
     * @example
     * // Count the number of Components
     * const count = await prisma.component.count({
     *   where: {
     *     // ... the filter for the Components we want to count
     *   }
     * })
    **/
    count<T extends ComponentCountArgs>(
      args?: Subset<T, ComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentAggregateArgs>(args: Subset<T, ComponentAggregateArgs>): Prisma.PrismaPromise<GetComponentAggregateType<T>>

    /**
     * Group by Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentGroupByArgs['orderBy'] }
        : { orderBy?: ComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Component model
   */
  readonly fields: ComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Component.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiRecommendations<T extends Component$aiRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Component$aiRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    alerts<T extends Component$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Component$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maintenance<T extends Component$maintenanceArgs<ExtArgs> = {}>(args?: Subset<T, Component$maintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Component model
   */
  interface ComponentFieldRefs {
    readonly id: FieldRef<"Component", 'String'>
    readonly vehicleId: FieldRef<"Component", 'String'>
    readonly componentType: FieldRef<"Component", 'String'>
    readonly name: FieldRef<"Component", 'String'>
    readonly status: FieldRef<"Component", 'String'>
    readonly healthScore: FieldRef<"Component", 'Float'>
    readonly expectedLifespan: FieldRef<"Component", 'Int'>
    readonly metadata: FieldRef<"Component", 'String'>
    readonly createdAt: FieldRef<"Component", 'DateTime'>
    readonly updatedAt: FieldRef<"Component", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Component findUnique
   */
  export type ComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findUniqueOrThrow
   */
  export type ComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findFirst
   */
  export type ComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findFirstOrThrow
   */
  export type ComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findMany
   */
  export type ComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Components to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component create
   */
  export type ComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a Component.
     */
    data: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
  }

  /**
   * Component createMany
   */
  export type ComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Component update
   */
  export type ComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a Component.
     */
    data: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
    /**
     * Choose, which Component to update.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component updateMany
   */
  export type ComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Components.
     */
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyInput>
    /**
     * Filter which Components to update
     */
    where?: ComponentWhereInput
    /**
     * Limit how many Components to update.
     */
    limit?: number
  }

  /**
   * Component upsert
   */
  export type ComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the Component to update in case it exists.
     */
    where: ComponentWhereUniqueInput
    /**
     * In case the Component found by the `where` argument doesn't exist, create a new Component with this data.
     */
    create: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
    /**
     * In case the Component was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
  }

  /**
   * Component delete
   */
  export type ComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter which Component to delete.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component deleteMany
   */
  export type ComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Components to delete
     */
    where?: ComponentWhereInput
    /**
     * Limit how many Components to delete.
     */
    limit?: number
  }

  /**
   * Component.aiRecommendations
   */
  export type Component$aiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    cursor?: AIRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * Component.alerts
   */
  export type Component$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Component.maintenance
   */
  export type Component$maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Component without action
   */
  export type ComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripAvgAggregateOutputType = {
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    distance: number | null
    fuelConsumed: number | null
  }

  export type TripSumAggregateOutputType = {
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    distance: number | null
    fuelConsumed: number | null
  }

  export type TripMinAggregateOutputType = {
    id: string | null
    vehicleId: string | null
    driverId: string | null
    startLocation: string | null
    endLocation: string | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    startTime: Date | null
    endTime: Date | null
    distance: number | null
    fuelConsumed: number | null
    status: string | null
    updatedAt: Date | null
  }

  export type TripMaxAggregateOutputType = {
    id: string | null
    vehicleId: string | null
    driverId: string | null
    startLocation: string | null
    endLocation: string | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    startTime: Date | null
    endTime: Date | null
    distance: number | null
    fuelConsumed: number | null
    status: string | null
    updatedAt: Date | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    vehicleId: number
    driverId: number
    startLocation: number
    endLocation: number
    startLatitude: number
    startLongitude: number
    endLatitude: number
    endLongitude: number
    startTime: number
    endTime: number
    distance: number
    fuelConsumed: number
    status: number
    updatedAt: number
    _all: number
  }


  export type TripAvgAggregateInputType = {
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    distance?: true
    fuelConsumed?: true
  }

  export type TripSumAggregateInputType = {
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    distance?: true
    fuelConsumed?: true
  }

  export type TripMinAggregateInputType = {
    id?: true
    vehicleId?: true
    driverId?: true
    startLocation?: true
    endLocation?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    startTime?: true
    endTime?: true
    distance?: true
    fuelConsumed?: true
    status?: true
    updatedAt?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    vehicleId?: true
    driverId?: true
    startLocation?: true
    endLocation?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    startTime?: true
    endTime?: true
    distance?: true
    fuelConsumed?: true
    status?: true
    updatedAt?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    vehicleId?: true
    driverId?: true
    startLocation?: true
    endLocation?: true
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    startTime?: true
    endTime?: true
    distance?: true
    fuelConsumed?: true
    status?: true
    updatedAt?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _avg?: TripAvgAggregateInputType
    _sum?: TripSumAggregateInputType
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: string
    vehicleId: string
    driverId: string
    startLocation: string | null
    endLocation: string | null
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    startTime: Date
    endTime: Date | null
    distance: number | null
    fuelConsumed: number | null
    status: string
    updatedAt: Date
    _count: TripCountAggregateOutputType | null
    _avg: TripAvgAggregateOutputType | null
    _sum: TripSumAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleId?: boolean
    driverId?: boolean
    startLocation?: boolean
    endLocation?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    startTime?: boolean
    endTime?: boolean
    distance?: boolean
    fuelConsumed?: boolean
    status?: boolean
    updatedAt?: boolean
    aiRecommendations?: boolean | Trip$aiRecommendationsArgs<ExtArgs>
    evaluation?: boolean | Trip$evaluationArgs<ExtArgs>
    metrics?: boolean | Trip$metricsArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>



  export type TripSelectScalar = {
    id?: boolean
    vehicleId?: boolean
    driverId?: boolean
    startLocation?: boolean
    endLocation?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    startTime?: boolean
    endTime?: boolean
    distance?: boolean
    fuelConsumed?: boolean
    status?: boolean
    updatedAt?: boolean
  }

  export type TripOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicleId" | "driverId" | "startLocation" | "endLocation" | "startLatitude" | "startLongitude" | "endLatitude" | "endLongitude" | "startTime" | "endTime" | "distance" | "fuelConsumed" | "status" | "updatedAt", ExtArgs["result"]["trip"]>
  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aiRecommendations?: boolean | Trip$aiRecommendationsArgs<ExtArgs>
    evaluation?: boolean | Trip$evaluationArgs<ExtArgs>
    metrics?: boolean | Trip$metricsArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      aiRecommendations: Prisma.$AIRecommendationPayload<ExtArgs>[]
      evaluation: Prisma.$DriverEvaluationPayload<ExtArgs> | null
      metrics: Prisma.$TripMetricPayload<ExtArgs>[]
      driver: Prisma.$DriverPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicleId: string
      driverId: string
      startLocation: string | null
      endLocation: string | null
      startLatitude: number | null
      startLongitude: number | null
      endLatitude: number | null
      endLongitude: number | null
      startTime: Date
      endTime: Date | null
      distance: number | null
      fuelConsumed: number | null
      status: string
      updatedAt: Date
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aiRecommendations<T extends Trip$aiRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$aiRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaluation<T extends Trip$evaluationArgs<ExtArgs> = {}>(args?: Subset<T, Trip$evaluationArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    metrics<T extends Trip$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Trip$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'String'>
    readonly vehicleId: FieldRef<"Trip", 'String'>
    readonly driverId: FieldRef<"Trip", 'String'>
    readonly startLocation: FieldRef<"Trip", 'String'>
    readonly endLocation: FieldRef<"Trip", 'String'>
    readonly startLatitude: FieldRef<"Trip", 'Float'>
    readonly startLongitude: FieldRef<"Trip", 'Float'>
    readonly endLatitude: FieldRef<"Trip", 'Float'>
    readonly endLongitude: FieldRef<"Trip", 'Float'>
    readonly startTime: FieldRef<"Trip", 'DateTime'>
    readonly endTime: FieldRef<"Trip", 'DateTime'>
    readonly distance: FieldRef<"Trip", 'Float'>
    readonly fuelConsumed: FieldRef<"Trip", 'Float'>
    readonly status: FieldRef<"Trip", 'String'>
    readonly updatedAt: FieldRef<"Trip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to update.
     */
    limit?: number
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to delete.
     */
    limit?: number
  }

  /**
   * Trip.aiRecommendations
   */
  export type Trip$aiRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    cursor?: AIRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * Trip.evaluation
   */
  export type Trip$evaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    where?: DriverEvaluationWhereInput
  }

  /**
   * Trip.metrics
   */
  export type Trip$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    where?: TripMetricWhereInput
    orderBy?: TripMetricOrderByWithRelationInput | TripMetricOrderByWithRelationInput[]
    cursor?: TripMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripMetricScalarFieldEnum | TripMetricScalarFieldEnum[]
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model TripMetric
   */

  export type AggregateTripMetric = {
    _count: TripMetricCountAggregateOutputType | null
    _avg: TripMetricAvgAggregateOutputType | null
    _sum: TripMetricSumAggregateOutputType | null
    _min: TripMetricMinAggregateOutputType | null
    _max: TripMetricMaxAggregateOutputType | null
  }

  export type TripMetricAvgAggregateOutputType = {
    speed: number | null
    acceleration: number | null
    braking: number | null
    fuelConsumption: number | null
    latitude: number | null
    longitude: number | null
  }

  export type TripMetricSumAggregateOutputType = {
    speed: number | null
    acceleration: number | null
    braking: number | null
    fuelConsumption: number | null
    latitude: number | null
    longitude: number | null
  }

  export type TripMetricMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    speed: number | null
    acceleration: number | null
    braking: number | null
    fuelConsumption: number | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
  }

  export type TripMetricMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    speed: number | null
    acceleration: number | null
    braking: number | null
    fuelConsumption: number | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
  }

  export type TripMetricCountAggregateOutputType = {
    id: number
    tripId: number
    speed: number
    acceleration: number
    braking: number
    fuelConsumption: number
    latitude: number
    longitude: number
    createdAt: number
    _all: number
  }


  export type TripMetricAvgAggregateInputType = {
    speed?: true
    acceleration?: true
    braking?: true
    fuelConsumption?: true
    latitude?: true
    longitude?: true
  }

  export type TripMetricSumAggregateInputType = {
    speed?: true
    acceleration?: true
    braking?: true
    fuelConsumption?: true
    latitude?: true
    longitude?: true
  }

  export type TripMetricMinAggregateInputType = {
    id?: true
    tripId?: true
    speed?: true
    acceleration?: true
    braking?: true
    fuelConsumption?: true
    latitude?: true
    longitude?: true
    createdAt?: true
  }

  export type TripMetricMaxAggregateInputType = {
    id?: true
    tripId?: true
    speed?: true
    acceleration?: true
    braking?: true
    fuelConsumption?: true
    latitude?: true
    longitude?: true
    createdAt?: true
  }

  export type TripMetricCountAggregateInputType = {
    id?: true
    tripId?: true
    speed?: true
    acceleration?: true
    braking?: true
    fuelConsumption?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    _all?: true
  }

  export type TripMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripMetric to aggregate.
     */
    where?: TripMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMetrics to fetch.
     */
    orderBy?: TripMetricOrderByWithRelationInput | TripMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripMetrics
    **/
    _count?: true | TripMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMetricMaxAggregateInputType
  }

  export type GetTripMetricAggregateType<T extends TripMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateTripMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripMetric[P]>
      : GetScalarType<T[P], AggregateTripMetric[P]>
  }




  export type TripMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripMetricWhereInput
    orderBy?: TripMetricOrderByWithAggregationInput | TripMetricOrderByWithAggregationInput[]
    by: TripMetricScalarFieldEnum[] | TripMetricScalarFieldEnum
    having?: TripMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripMetricCountAggregateInputType | true
    _avg?: TripMetricAvgAggregateInputType
    _sum?: TripMetricSumAggregateInputType
    _min?: TripMetricMinAggregateInputType
    _max?: TripMetricMaxAggregateInputType
  }

  export type TripMetricGroupByOutputType = {
    id: string
    tripId: string
    speed: number | null
    acceleration: number | null
    braking: number | null
    fuelConsumption: number | null
    latitude: number | null
    longitude: number | null
    createdAt: Date
    _count: TripMetricCountAggregateOutputType | null
    _avg: TripMetricAvgAggregateOutputType | null
    _sum: TripMetricSumAggregateOutputType | null
    _min: TripMetricMinAggregateOutputType | null
    _max: TripMetricMaxAggregateOutputType | null
  }

  type GetTripMetricGroupByPayload<T extends TripMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripMetricGroupByOutputType[P]>
            : GetScalarType<T[P], TripMetricGroupByOutputType[P]>
        }
      >
    >


  export type TripMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    speed?: boolean
    acceleration?: boolean
    braking?: boolean
    fuelConsumption?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripMetric"]>



  export type TripMetricSelectScalar = {
    id?: boolean
    tripId?: boolean
    speed?: boolean
    acceleration?: boolean
    braking?: boolean
    fuelConsumption?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
  }

  export type TripMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripId" | "speed" | "acceleration" | "braking" | "fuelConsumption" | "latitude" | "longitude" | "createdAt", ExtArgs["result"]["tripMetric"]>
  export type TripMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }

  export type $TripMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripMetric"
    objects: {
      trip: Prisma.$TripPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      speed: number | null
      acceleration: number | null
      braking: number | null
      fuelConsumption: number | null
      latitude: number | null
      longitude: number | null
      createdAt: Date
    }, ExtArgs["result"]["tripMetric"]>
    composites: {}
  }

  type TripMetricGetPayload<S extends boolean | null | undefined | TripMetricDefaultArgs> = $Result.GetResult<Prisma.$TripMetricPayload, S>

  type TripMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripMetricCountAggregateInputType | true
    }

  export interface TripMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripMetric'], meta: { name: 'TripMetric' } }
    /**
     * Find zero or one TripMetric that matches the filter.
     * @param {TripMetricFindUniqueArgs} args - Arguments to find a TripMetric
     * @example
     * // Get one TripMetric
     * const tripMetric = await prisma.tripMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripMetricFindUniqueArgs>(args: SelectSubset<T, TripMetricFindUniqueArgs<ExtArgs>>): Prisma__TripMetricClient<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TripMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripMetricFindUniqueOrThrowArgs} args - Arguments to find a TripMetric
     * @example
     * // Get one TripMetric
     * const tripMetric = await prisma.tripMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, TripMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripMetricClient<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMetricFindFirstArgs} args - Arguments to find a TripMetric
     * @example
     * // Get one TripMetric
     * const tripMetric = await prisma.tripMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripMetricFindFirstArgs>(args?: SelectSubset<T, TripMetricFindFirstArgs<ExtArgs>>): Prisma__TripMetricClient<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMetricFindFirstOrThrowArgs} args - Arguments to find a TripMetric
     * @example
     * // Get one TripMetric
     * const tripMetric = await prisma.tripMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, TripMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripMetricClient<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TripMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripMetrics
     * const tripMetrics = await prisma.tripMetric.findMany()
     * 
     * // Get first 10 TripMetrics
     * const tripMetrics = await prisma.tripMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripMetricWithIdOnly = await prisma.tripMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripMetricFindManyArgs>(args?: SelectSubset<T, TripMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TripMetric.
     * @param {TripMetricCreateArgs} args - Arguments to create a TripMetric.
     * @example
     * // Create one TripMetric
     * const TripMetric = await prisma.tripMetric.create({
     *   data: {
     *     // ... data to create a TripMetric
     *   }
     * })
     * 
     */
    create<T extends TripMetricCreateArgs>(args: SelectSubset<T, TripMetricCreateArgs<ExtArgs>>): Prisma__TripMetricClient<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TripMetrics.
     * @param {TripMetricCreateManyArgs} args - Arguments to create many TripMetrics.
     * @example
     * // Create many TripMetrics
     * const tripMetric = await prisma.tripMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripMetricCreateManyArgs>(args?: SelectSubset<T, TripMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TripMetric.
     * @param {TripMetricDeleteArgs} args - Arguments to delete one TripMetric.
     * @example
     * // Delete one TripMetric
     * const TripMetric = await prisma.tripMetric.delete({
     *   where: {
     *     // ... filter to delete one TripMetric
     *   }
     * })
     * 
     */
    delete<T extends TripMetricDeleteArgs>(args: SelectSubset<T, TripMetricDeleteArgs<ExtArgs>>): Prisma__TripMetricClient<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TripMetric.
     * @param {TripMetricUpdateArgs} args - Arguments to update one TripMetric.
     * @example
     * // Update one TripMetric
     * const tripMetric = await prisma.tripMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripMetricUpdateArgs>(args: SelectSubset<T, TripMetricUpdateArgs<ExtArgs>>): Prisma__TripMetricClient<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TripMetrics.
     * @param {TripMetricDeleteManyArgs} args - Arguments to filter TripMetrics to delete.
     * @example
     * // Delete a few TripMetrics
     * const { count } = await prisma.tripMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripMetricDeleteManyArgs>(args?: SelectSubset<T, TripMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripMetrics
     * const tripMetric = await prisma.tripMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripMetricUpdateManyArgs>(args: SelectSubset<T, TripMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TripMetric.
     * @param {TripMetricUpsertArgs} args - Arguments to update or create a TripMetric.
     * @example
     * // Update or create a TripMetric
     * const tripMetric = await prisma.tripMetric.upsert({
     *   create: {
     *     // ... data to create a TripMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripMetric we want to update
     *   }
     * })
     */
    upsert<T extends TripMetricUpsertArgs>(args: SelectSubset<T, TripMetricUpsertArgs<ExtArgs>>): Prisma__TripMetricClient<$Result.GetResult<Prisma.$TripMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TripMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMetricCountArgs} args - Arguments to filter TripMetrics to count.
     * @example
     * // Count the number of TripMetrics
     * const count = await prisma.tripMetric.count({
     *   where: {
     *     // ... the filter for the TripMetrics we want to count
     *   }
     * })
    **/
    count<T extends TripMetricCountArgs>(
      args?: Subset<T, TripMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripMetricAggregateArgs>(args: Subset<T, TripMetricAggregateArgs>): Prisma.PrismaPromise<GetTripMetricAggregateType<T>>

    /**
     * Group by TripMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripMetricGroupByArgs['orderBy'] }
        : { orderBy?: TripMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripMetric model
   */
  readonly fields: TripMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripMetric model
   */
  interface TripMetricFieldRefs {
    readonly id: FieldRef<"TripMetric", 'String'>
    readonly tripId: FieldRef<"TripMetric", 'String'>
    readonly speed: FieldRef<"TripMetric", 'Float'>
    readonly acceleration: FieldRef<"TripMetric", 'Float'>
    readonly braking: FieldRef<"TripMetric", 'Float'>
    readonly fuelConsumption: FieldRef<"TripMetric", 'Float'>
    readonly latitude: FieldRef<"TripMetric", 'Float'>
    readonly longitude: FieldRef<"TripMetric", 'Float'>
    readonly createdAt: FieldRef<"TripMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripMetric findUnique
   */
  export type TripMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * Filter, which TripMetric to fetch.
     */
    where: TripMetricWhereUniqueInput
  }

  /**
   * TripMetric findUniqueOrThrow
   */
  export type TripMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * Filter, which TripMetric to fetch.
     */
    where: TripMetricWhereUniqueInput
  }

  /**
   * TripMetric findFirst
   */
  export type TripMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * Filter, which TripMetric to fetch.
     */
    where?: TripMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMetrics to fetch.
     */
    orderBy?: TripMetricOrderByWithRelationInput | TripMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripMetrics.
     */
    cursor?: TripMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripMetrics.
     */
    distinct?: TripMetricScalarFieldEnum | TripMetricScalarFieldEnum[]
  }

  /**
   * TripMetric findFirstOrThrow
   */
  export type TripMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * Filter, which TripMetric to fetch.
     */
    where?: TripMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMetrics to fetch.
     */
    orderBy?: TripMetricOrderByWithRelationInput | TripMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripMetrics.
     */
    cursor?: TripMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripMetrics.
     */
    distinct?: TripMetricScalarFieldEnum | TripMetricScalarFieldEnum[]
  }

  /**
   * TripMetric findMany
   */
  export type TripMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * Filter, which TripMetrics to fetch.
     */
    where?: TripMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripMetrics to fetch.
     */
    orderBy?: TripMetricOrderByWithRelationInput | TripMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripMetrics.
     */
    cursor?: TripMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripMetrics.
     */
    skip?: number
    distinct?: TripMetricScalarFieldEnum | TripMetricScalarFieldEnum[]
  }

  /**
   * TripMetric create
   */
  export type TripMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a TripMetric.
     */
    data: XOR<TripMetricCreateInput, TripMetricUncheckedCreateInput>
  }

  /**
   * TripMetric createMany
   */
  export type TripMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripMetrics.
     */
    data: TripMetricCreateManyInput | TripMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TripMetric update
   */
  export type TripMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a TripMetric.
     */
    data: XOR<TripMetricUpdateInput, TripMetricUncheckedUpdateInput>
    /**
     * Choose, which TripMetric to update.
     */
    where: TripMetricWhereUniqueInput
  }

  /**
   * TripMetric updateMany
   */
  export type TripMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripMetrics.
     */
    data: XOR<TripMetricUpdateManyMutationInput, TripMetricUncheckedUpdateManyInput>
    /**
     * Filter which TripMetrics to update
     */
    where?: TripMetricWhereInput
    /**
     * Limit how many TripMetrics to update.
     */
    limit?: number
  }

  /**
   * TripMetric upsert
   */
  export type TripMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the TripMetric to update in case it exists.
     */
    where: TripMetricWhereUniqueInput
    /**
     * In case the TripMetric found by the `where` argument doesn't exist, create a new TripMetric with this data.
     */
    create: XOR<TripMetricCreateInput, TripMetricUncheckedCreateInput>
    /**
     * In case the TripMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripMetricUpdateInput, TripMetricUncheckedUpdateInput>
  }

  /**
   * TripMetric delete
   */
  export type TripMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
    /**
     * Filter which TripMetric to delete.
     */
    where: TripMetricWhereUniqueInput
  }

  /**
   * TripMetric deleteMany
   */
  export type TripMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripMetrics to delete
     */
    where?: TripMetricWhereInput
    /**
     * Limit how many TripMetrics to delete.
     */
    limit?: number
  }

  /**
   * TripMetric without action
   */
  export type TripMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripMetric
     */
    select?: TripMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripMetric
     */
    omit?: TripMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripMetricInclude<ExtArgs> | null
  }


  /**
   * Model DriverEvaluation
   */

  export type AggregateDriverEvaluation = {
    _count: DriverEvaluationCountAggregateOutputType | null
    _avg: DriverEvaluationAvgAggregateOutputType | null
    _sum: DriverEvaluationSumAggregateOutputType | null
    _min: DriverEvaluationMinAggregateOutputType | null
    _max: DriverEvaluationMaxAggregateOutputType | null
  }

  export type DriverEvaluationAvgAggregateOutputType = {
    safetyScore: number | null
    fuelEfficiencyScore: number | null
    speedingInstances: number | null
    hardBrakingCount: number | null
    hardAccelerationCount: number | null
    distractionScore: number | null
    overallScore: number | null
  }

  export type DriverEvaluationSumAggregateOutputType = {
    safetyScore: number | null
    fuelEfficiencyScore: number | null
    speedingInstances: number | null
    hardBrakingCount: number | null
    hardAccelerationCount: number | null
    distractionScore: number | null
    overallScore: number | null
  }

  export type DriverEvaluationMinAggregateOutputType = {
    id: string | null
    driverId: string | null
    tripId: string | null
    safetyScore: number | null
    fuelEfficiencyScore: number | null
    speedingInstances: number | null
    hardBrakingCount: number | null
    hardAccelerationCount: number | null
    distractionScore: number | null
    overallScore: number | null
    recommendations: string | null
    createdAt: Date | null
  }

  export type DriverEvaluationMaxAggregateOutputType = {
    id: string | null
    driverId: string | null
    tripId: string | null
    safetyScore: number | null
    fuelEfficiencyScore: number | null
    speedingInstances: number | null
    hardBrakingCount: number | null
    hardAccelerationCount: number | null
    distractionScore: number | null
    overallScore: number | null
    recommendations: string | null
    createdAt: Date | null
  }

  export type DriverEvaluationCountAggregateOutputType = {
    id: number
    driverId: number
    tripId: number
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations: number
    createdAt: number
    _all: number
  }


  export type DriverEvaluationAvgAggregateInputType = {
    safetyScore?: true
    fuelEfficiencyScore?: true
    speedingInstances?: true
    hardBrakingCount?: true
    hardAccelerationCount?: true
    distractionScore?: true
    overallScore?: true
  }

  export type DriverEvaluationSumAggregateInputType = {
    safetyScore?: true
    fuelEfficiencyScore?: true
    speedingInstances?: true
    hardBrakingCount?: true
    hardAccelerationCount?: true
    distractionScore?: true
    overallScore?: true
  }

  export type DriverEvaluationMinAggregateInputType = {
    id?: true
    driverId?: true
    tripId?: true
    safetyScore?: true
    fuelEfficiencyScore?: true
    speedingInstances?: true
    hardBrakingCount?: true
    hardAccelerationCount?: true
    distractionScore?: true
    overallScore?: true
    recommendations?: true
    createdAt?: true
  }

  export type DriverEvaluationMaxAggregateInputType = {
    id?: true
    driverId?: true
    tripId?: true
    safetyScore?: true
    fuelEfficiencyScore?: true
    speedingInstances?: true
    hardBrakingCount?: true
    hardAccelerationCount?: true
    distractionScore?: true
    overallScore?: true
    recommendations?: true
    createdAt?: true
  }

  export type DriverEvaluationCountAggregateInputType = {
    id?: true
    driverId?: true
    tripId?: true
    safetyScore?: true
    fuelEfficiencyScore?: true
    speedingInstances?: true
    hardBrakingCount?: true
    hardAccelerationCount?: true
    distractionScore?: true
    overallScore?: true
    recommendations?: true
    createdAt?: true
    _all?: true
  }

  export type DriverEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverEvaluation to aggregate.
     */
    where?: DriverEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverEvaluations to fetch.
     */
    orderBy?: DriverEvaluationOrderByWithRelationInput | DriverEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriverEvaluations
    **/
    _count?: true | DriverEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverEvaluationMaxAggregateInputType
  }

  export type GetDriverEvaluationAggregateType<T extends DriverEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverEvaluation[P]>
      : GetScalarType<T[P], AggregateDriverEvaluation[P]>
  }




  export type DriverEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverEvaluationWhereInput
    orderBy?: DriverEvaluationOrderByWithAggregationInput | DriverEvaluationOrderByWithAggregationInput[]
    by: DriverEvaluationScalarFieldEnum[] | DriverEvaluationScalarFieldEnum
    having?: DriverEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverEvaluationCountAggregateInputType | true
    _avg?: DriverEvaluationAvgAggregateInputType
    _sum?: DriverEvaluationSumAggregateInputType
    _min?: DriverEvaluationMinAggregateInputType
    _max?: DriverEvaluationMaxAggregateInputType
  }

  export type DriverEvaluationGroupByOutputType = {
    id: string
    driverId: string
    tripId: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations: string | null
    createdAt: Date
    _count: DriverEvaluationCountAggregateOutputType | null
    _avg: DriverEvaluationAvgAggregateOutputType | null
    _sum: DriverEvaluationSumAggregateOutputType | null
    _min: DriverEvaluationMinAggregateOutputType | null
    _max: DriverEvaluationMaxAggregateOutputType | null
  }

  type GetDriverEvaluationGroupByPayload<T extends DriverEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], DriverEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type DriverEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    tripId?: boolean
    safetyScore?: boolean
    fuelEfficiencyScore?: boolean
    speedingInstances?: boolean
    hardBrakingCount?: boolean
    hardAccelerationCount?: boolean
    distractionScore?: boolean
    overallScore?: boolean
    recommendations?: boolean
    createdAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverEvaluation"]>



  export type DriverEvaluationSelectScalar = {
    id?: boolean
    driverId?: boolean
    tripId?: boolean
    safetyScore?: boolean
    fuelEfficiencyScore?: boolean
    speedingInstances?: boolean
    hardBrakingCount?: boolean
    hardAccelerationCount?: boolean
    distractionScore?: boolean
    overallScore?: boolean
    recommendations?: boolean
    createdAt?: boolean
  }

  export type DriverEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "driverId" | "tripId" | "safetyScore" | "fuelEfficiencyScore" | "speedingInstances" | "hardBrakingCount" | "hardAccelerationCount" | "distractionScore" | "overallScore" | "recommendations" | "createdAt", ExtArgs["result"]["driverEvaluation"]>
  export type DriverEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }

  export type $DriverEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriverEvaluation"
    objects: {
      driver: Prisma.$DriverPayload<ExtArgs>
      trip: Prisma.$TripPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      driverId: string
      tripId: string
      safetyScore: number
      fuelEfficiencyScore: number
      speedingInstances: number
      hardBrakingCount: number
      hardAccelerationCount: number
      distractionScore: number
      overallScore: number
      recommendations: string | null
      createdAt: Date
    }, ExtArgs["result"]["driverEvaluation"]>
    composites: {}
  }

  type DriverEvaluationGetPayload<S extends boolean | null | undefined | DriverEvaluationDefaultArgs> = $Result.GetResult<Prisma.$DriverEvaluationPayload, S>

  type DriverEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverEvaluationCountAggregateInputType | true
    }

  export interface DriverEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriverEvaluation'], meta: { name: 'DriverEvaluation' } }
    /**
     * Find zero or one DriverEvaluation that matches the filter.
     * @param {DriverEvaluationFindUniqueArgs} args - Arguments to find a DriverEvaluation
     * @example
     * // Get one DriverEvaluation
     * const driverEvaluation = await prisma.driverEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverEvaluationFindUniqueArgs>(args: SelectSubset<T, DriverEvaluationFindUniqueArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DriverEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverEvaluationFindUniqueOrThrowArgs} args - Arguments to find a DriverEvaluation
     * @example
     * // Get one DriverEvaluation
     * const driverEvaluation = await prisma.driverEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverEvaluationFindFirstArgs} args - Arguments to find a DriverEvaluation
     * @example
     * // Get one DriverEvaluation
     * const driverEvaluation = await prisma.driverEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverEvaluationFindFirstArgs>(args?: SelectSubset<T, DriverEvaluationFindFirstArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverEvaluationFindFirstOrThrowArgs} args - Arguments to find a DriverEvaluation
     * @example
     * // Get one DriverEvaluation
     * const driverEvaluation = await prisma.driverEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DriverEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverEvaluations
     * const driverEvaluations = await prisma.driverEvaluation.findMany()
     * 
     * // Get first 10 DriverEvaluations
     * const driverEvaluations = await prisma.driverEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverEvaluationWithIdOnly = await prisma.driverEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverEvaluationFindManyArgs>(args?: SelectSubset<T, DriverEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DriverEvaluation.
     * @param {DriverEvaluationCreateArgs} args - Arguments to create a DriverEvaluation.
     * @example
     * // Create one DriverEvaluation
     * const DriverEvaluation = await prisma.driverEvaluation.create({
     *   data: {
     *     // ... data to create a DriverEvaluation
     *   }
     * })
     * 
     */
    create<T extends DriverEvaluationCreateArgs>(args: SelectSubset<T, DriverEvaluationCreateArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DriverEvaluations.
     * @param {DriverEvaluationCreateManyArgs} args - Arguments to create many DriverEvaluations.
     * @example
     * // Create many DriverEvaluations
     * const driverEvaluation = await prisma.driverEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverEvaluationCreateManyArgs>(args?: SelectSubset<T, DriverEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DriverEvaluation.
     * @param {DriverEvaluationDeleteArgs} args - Arguments to delete one DriverEvaluation.
     * @example
     * // Delete one DriverEvaluation
     * const DriverEvaluation = await prisma.driverEvaluation.delete({
     *   where: {
     *     // ... filter to delete one DriverEvaluation
     *   }
     * })
     * 
     */
    delete<T extends DriverEvaluationDeleteArgs>(args: SelectSubset<T, DriverEvaluationDeleteArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DriverEvaluation.
     * @param {DriverEvaluationUpdateArgs} args - Arguments to update one DriverEvaluation.
     * @example
     * // Update one DriverEvaluation
     * const driverEvaluation = await prisma.driverEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverEvaluationUpdateArgs>(args: SelectSubset<T, DriverEvaluationUpdateArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DriverEvaluations.
     * @param {DriverEvaluationDeleteManyArgs} args - Arguments to filter DriverEvaluations to delete.
     * @example
     * // Delete a few DriverEvaluations
     * const { count } = await prisma.driverEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverEvaluationDeleteManyArgs>(args?: SelectSubset<T, DriverEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverEvaluations
     * const driverEvaluation = await prisma.driverEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverEvaluationUpdateManyArgs>(args: SelectSubset<T, DriverEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DriverEvaluation.
     * @param {DriverEvaluationUpsertArgs} args - Arguments to update or create a DriverEvaluation.
     * @example
     * // Update or create a DriverEvaluation
     * const driverEvaluation = await prisma.driverEvaluation.upsert({
     *   create: {
     *     // ... data to create a DriverEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends DriverEvaluationUpsertArgs>(args: SelectSubset<T, DriverEvaluationUpsertArgs<ExtArgs>>): Prisma__DriverEvaluationClient<$Result.GetResult<Prisma.$DriverEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DriverEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverEvaluationCountArgs} args - Arguments to filter DriverEvaluations to count.
     * @example
     * // Count the number of DriverEvaluations
     * const count = await prisma.driverEvaluation.count({
     *   where: {
     *     // ... the filter for the DriverEvaluations we want to count
     *   }
     * })
    **/
    count<T extends DriverEvaluationCountArgs>(
      args?: Subset<T, DriverEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriverEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverEvaluationAggregateArgs>(args: Subset<T, DriverEvaluationAggregateArgs>): Prisma.PrismaPromise<GetDriverEvaluationAggregateType<T>>

    /**
     * Group by DriverEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: DriverEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriverEvaluation model
   */
  readonly fields: DriverEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriverEvaluation model
   */
  interface DriverEvaluationFieldRefs {
    readonly id: FieldRef<"DriverEvaluation", 'String'>
    readonly driverId: FieldRef<"DriverEvaluation", 'String'>
    readonly tripId: FieldRef<"DriverEvaluation", 'String'>
    readonly safetyScore: FieldRef<"DriverEvaluation", 'Float'>
    readonly fuelEfficiencyScore: FieldRef<"DriverEvaluation", 'Float'>
    readonly speedingInstances: FieldRef<"DriverEvaluation", 'Int'>
    readonly hardBrakingCount: FieldRef<"DriverEvaluation", 'Int'>
    readonly hardAccelerationCount: FieldRef<"DriverEvaluation", 'Int'>
    readonly distractionScore: FieldRef<"DriverEvaluation", 'Float'>
    readonly overallScore: FieldRef<"DriverEvaluation", 'Float'>
    readonly recommendations: FieldRef<"DriverEvaluation", 'String'>
    readonly createdAt: FieldRef<"DriverEvaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DriverEvaluation findUnique
   */
  export type DriverEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which DriverEvaluation to fetch.
     */
    where: DriverEvaluationWhereUniqueInput
  }

  /**
   * DriverEvaluation findUniqueOrThrow
   */
  export type DriverEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which DriverEvaluation to fetch.
     */
    where: DriverEvaluationWhereUniqueInput
  }

  /**
   * DriverEvaluation findFirst
   */
  export type DriverEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which DriverEvaluation to fetch.
     */
    where?: DriverEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverEvaluations to fetch.
     */
    orderBy?: DriverEvaluationOrderByWithRelationInput | DriverEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverEvaluations.
     */
    cursor?: DriverEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverEvaluations.
     */
    distinct?: DriverEvaluationScalarFieldEnum | DriverEvaluationScalarFieldEnum[]
  }

  /**
   * DriverEvaluation findFirstOrThrow
   */
  export type DriverEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which DriverEvaluation to fetch.
     */
    where?: DriverEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverEvaluations to fetch.
     */
    orderBy?: DriverEvaluationOrderByWithRelationInput | DriverEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverEvaluations.
     */
    cursor?: DriverEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverEvaluations.
     */
    distinct?: DriverEvaluationScalarFieldEnum | DriverEvaluationScalarFieldEnum[]
  }

  /**
   * DriverEvaluation findMany
   */
  export type DriverEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which DriverEvaluations to fetch.
     */
    where?: DriverEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverEvaluations to fetch.
     */
    orderBy?: DriverEvaluationOrderByWithRelationInput | DriverEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriverEvaluations.
     */
    cursor?: DriverEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverEvaluations.
     */
    skip?: number
    distinct?: DriverEvaluationScalarFieldEnum | DriverEvaluationScalarFieldEnum[]
  }

  /**
   * DriverEvaluation create
   */
  export type DriverEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a DriverEvaluation.
     */
    data: XOR<DriverEvaluationCreateInput, DriverEvaluationUncheckedCreateInput>
  }

  /**
   * DriverEvaluation createMany
   */
  export type DriverEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriverEvaluations.
     */
    data: DriverEvaluationCreateManyInput | DriverEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriverEvaluation update
   */
  export type DriverEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a DriverEvaluation.
     */
    data: XOR<DriverEvaluationUpdateInput, DriverEvaluationUncheckedUpdateInput>
    /**
     * Choose, which DriverEvaluation to update.
     */
    where: DriverEvaluationWhereUniqueInput
  }

  /**
   * DriverEvaluation updateMany
   */
  export type DriverEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriverEvaluations.
     */
    data: XOR<DriverEvaluationUpdateManyMutationInput, DriverEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which DriverEvaluations to update
     */
    where?: DriverEvaluationWhereInput
    /**
     * Limit how many DriverEvaluations to update.
     */
    limit?: number
  }

  /**
   * DriverEvaluation upsert
   */
  export type DriverEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the DriverEvaluation to update in case it exists.
     */
    where: DriverEvaluationWhereUniqueInput
    /**
     * In case the DriverEvaluation found by the `where` argument doesn't exist, create a new DriverEvaluation with this data.
     */
    create: XOR<DriverEvaluationCreateInput, DriverEvaluationUncheckedCreateInput>
    /**
     * In case the DriverEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverEvaluationUpdateInput, DriverEvaluationUncheckedUpdateInput>
  }

  /**
   * DriverEvaluation delete
   */
  export type DriverEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
    /**
     * Filter which DriverEvaluation to delete.
     */
    where: DriverEvaluationWhereUniqueInput
  }

  /**
   * DriverEvaluation deleteMany
   */
  export type DriverEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverEvaluations to delete
     */
    where?: DriverEvaluationWhereInput
    /**
     * Limit how many DriverEvaluations to delete.
     */
    limit?: number
  }

  /**
   * DriverEvaluation without action
   */
  export type DriverEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverEvaluation
     */
    select?: DriverEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverEvaluation
     */
    omit?: DriverEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    type: string | null
    vehicleId: string | null
    componentId: string | null
    message: string | null
    actionRequired: boolean | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    type: string | null
    vehicleId: string | null
    componentId: string | null
    message: string | null
    actionRequired: boolean | null
    createdAt: Date | null
    resolvedAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    type: number
    vehicleId: number
    componentId: number
    message: number
    actionRequired: number
    createdAt: number
    resolvedAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    type?: true
    vehicleId?: true
    componentId?: true
    message?: true
    actionRequired?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    type?: true
    vehicleId?: true
    componentId?: true
    message?: true
    actionRequired?: true
    createdAt?: true
    resolvedAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    type?: true
    vehicleId?: true
    componentId?: true
    message?: true
    actionRequired?: true
    createdAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    type: string
    vehicleId: string
    componentId: string | null
    message: string
    actionRequired: boolean
    createdAt: Date
    resolvedAt: Date | null
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    vehicleId?: boolean
    componentId?: boolean
    message?: boolean
    actionRequired?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
    component?: boolean | Alert$componentArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>



  export type AlertSelectScalar = {
    id?: boolean
    type?: boolean
    vehicleId?: boolean
    componentId?: boolean
    message?: boolean
    actionRequired?: boolean
    createdAt?: boolean
    resolvedAt?: boolean
  }

  export type AlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "vehicleId" | "componentId" | "message" | "actionRequired" | "createdAt" | "resolvedAt", ExtArgs["result"]["alert"]>
  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | Alert$componentArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      vehicleId: string
      componentId: string | null
      message: string
      actionRequired: boolean
      createdAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends Alert$componentArgs<ExtArgs> = {}>(args?: Subset<T, Alert$componentArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly type: FieldRef<"Alert", 'String'>
    readonly vehicleId: FieldRef<"Alert", 'String'>
    readonly componentId: FieldRef<"Alert", 'String'>
    readonly message: FieldRef<"Alert", 'String'>
    readonly actionRequired: FieldRef<"Alert", 'Boolean'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly resolvedAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to update.
     */
    limit?: number
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
    /**
     * Limit how many Alerts to delete.
     */
    limit?: number
  }

  /**
   * Alert.component
   */
  export type Alert$componentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alert
     */
    omit?: AlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model Maintenance
   */

  export type AggregateMaintenance = {
    _count: MaintenanceCountAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  export type MaintenanceMinAggregateOutputType = {
    id: string | null
    vehicleId: string | null
    componentId: string | null
    maintenanceType: string | null
    description: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceMaxAggregateOutputType = {
    id: string | null
    vehicleId: string | null
    componentId: string | null
    maintenanceType: string | null
    description: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceCountAggregateOutputType = {
    id: number
    vehicleId: number
    componentId: number
    maintenanceType: number
    description: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceMinAggregateInputType = {
    id?: true
    vehicleId?: true
    componentId?: true
    maintenanceType?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceMaxAggregateInputType = {
    id?: true
    vehicleId?: true
    componentId?: true
    maintenanceType?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceCountAggregateInputType = {
    id?: true
    vehicleId?: true
    componentId?: true
    maintenanceType?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenance to aggregate.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maintenances
    **/
    _count?: true | MaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceMaxAggregateInputType
  }

  export type GetMaintenanceAggregateType<T extends MaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance[P]>
      : GetScalarType<T[P], AggregateMaintenance[P]>
  }




  export type MaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithAggregationInput | MaintenanceOrderByWithAggregationInput[]
    by: MaintenanceScalarFieldEnum[] | MaintenanceScalarFieldEnum
    having?: MaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceCountAggregateInputType | true
    _min?: MaintenanceMinAggregateInputType
    _max?: MaintenanceMaxAggregateInputType
  }

  export type MaintenanceGroupByOutputType = {
    id: string
    vehicleId: string
    componentId: string | null
    maintenanceType: string
    description: string
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceCountAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  type GetMaintenanceGroupByPayload<T extends MaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicleId?: boolean
    componentId?: boolean
    maintenanceType?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    component?: boolean | Maintenance$componentArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>



  export type MaintenanceSelectScalar = {
    id?: boolean
    vehicleId?: boolean
    componentId?: boolean
    maintenanceType?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicleId" | "componentId" | "maintenanceType" | "description" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["maintenance"]>
  export type MaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | Maintenance$componentArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $MaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maintenance"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicleId: string
      componentId: string | null
      maintenanceType: string
      description: string
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenance"]>
    composites: {}
  }

  type MaintenanceGetPayload<S extends boolean | null | undefined | MaintenanceDefaultArgs> = $Result.GetResult<Prisma.$MaintenancePayload, S>

  type MaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceCountAggregateInputType | true
    }

  export interface MaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maintenance'], meta: { name: 'Maintenance' } }
    /**
     * Find zero or one Maintenance that matches the filter.
     * @param {MaintenanceFindUniqueArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceFindUniqueArgs>(args: SelectSubset<T, MaintenanceFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceFindUniqueOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceFindFirstArgs>(args?: SelectSubset<T, MaintenanceFindFirstArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenances
     * const maintenances = await prisma.maintenance.findMany()
     * 
     * // Get first 10 Maintenances
     * const maintenances = await prisma.maintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceFindManyArgs>(args?: SelectSubset<T, MaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintenance.
     * @param {MaintenanceCreateArgs} args - Arguments to create a Maintenance.
     * @example
     * // Create one Maintenance
     * const Maintenance = await prisma.maintenance.create({
     *   data: {
     *     // ... data to create a Maintenance
     *   }
     * })
     * 
     */
    create<T extends MaintenanceCreateArgs>(args: SelectSubset<T, MaintenanceCreateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintenances.
     * @param {MaintenanceCreateManyArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceCreateManyArgs>(args?: SelectSubset<T, MaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Maintenance.
     * @param {MaintenanceDeleteArgs} args - Arguments to delete one Maintenance.
     * @example
     * // Delete one Maintenance
     * const Maintenance = await prisma.maintenance.delete({
     *   where: {
     *     // ... filter to delete one Maintenance
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceDeleteArgs>(args: SelectSubset<T, MaintenanceDeleteArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintenance.
     * @param {MaintenanceUpdateArgs} args - Arguments to update one Maintenance.
     * @example
     * // Update one Maintenance
     * const maintenance = await prisma.maintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceUpdateArgs>(args: SelectSubset<T, MaintenanceUpdateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintenances.
     * @param {MaintenanceDeleteManyArgs} args - Arguments to filter Maintenances to delete.
     * @example
     * // Delete a few Maintenances
     * const { count } = await prisma.maintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceDeleteManyArgs>(args?: SelectSubset<T, MaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceUpdateManyArgs>(args: SelectSubset<T, MaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Maintenance.
     * @param {MaintenanceUpsertArgs} args - Arguments to update or create a Maintenance.
     * @example
     * // Update or create a Maintenance
     * const maintenance = await prisma.maintenance.upsert({
     *   create: {
     *     // ... data to create a Maintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceUpsertArgs>(args: SelectSubset<T, MaintenanceUpsertArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCountArgs} args - Arguments to filter Maintenances to count.
     * @example
     * // Count the number of Maintenances
     * const count = await prisma.maintenance.count({
     *   where: {
     *     // ... the filter for the Maintenances we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceCountArgs>(
      args?: Subset<T, MaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceAggregateArgs>(args: Subset<T, MaintenanceAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceAggregateType<T>>

    /**
     * Group by Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maintenance model
   */
  readonly fields: MaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends Maintenance$componentArgs<ExtArgs> = {}>(args?: Subset<T, Maintenance$componentArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maintenance model
   */
  interface MaintenanceFieldRefs {
    readonly id: FieldRef<"Maintenance", 'String'>
    readonly vehicleId: FieldRef<"Maintenance", 'String'>
    readonly componentId: FieldRef<"Maintenance", 'String'>
    readonly maintenanceType: FieldRef<"Maintenance", 'String'>
    readonly description: FieldRef<"Maintenance", 'String'>
    readonly metadata: FieldRef<"Maintenance", 'String'>
    readonly createdAt: FieldRef<"Maintenance", 'DateTime'>
    readonly updatedAt: FieldRef<"Maintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Maintenance findUnique
   */
  export type MaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findUniqueOrThrow
   */
  export type MaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findFirst
   */
  export type MaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findFirstOrThrow
   */
  export type MaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findMany
   */
  export type MaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenances to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance create
   */
  export type MaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Maintenance.
     */
    data: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
  }

  /**
   * Maintenance createMany
   */
  export type MaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintenance update
   */
  export type MaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Maintenance.
     */
    data: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
    /**
     * Choose, which Maintenance to update.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance updateMany
   */
  export type MaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
  }

  /**
   * Maintenance upsert
   */
  export type MaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Maintenance to update in case it exists.
     */
    where: MaintenanceWhereUniqueInput
    /**
     * In case the Maintenance found by the `where` argument doesn't exist, create a new Maintenance with this data.
     */
    create: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
    /**
     * In case the Maintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
  }

  /**
   * Maintenance delete
   */
  export type MaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter which Maintenance to delete.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance deleteMany
   */
  export type MaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenances to delete
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to delete.
     */
    limit?: number
  }

  /**
   * Maintenance.component
   */
  export type Maintenance$componentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
  }

  /**
   * Maintenance without action
   */
  export type MaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model AIRecommendation
   */

  export type AggregateAIRecommendation = {
    _count: AIRecommendationCountAggregateOutputType | null
    _min: AIRecommendationMinAggregateOutputType | null
    _max: AIRecommendationMaxAggregateOutputType | null
  }

  export type AIRecommendationMinAggregateOutputType = {
    id: string | null
    targetType: string | null
    targetId: string | null
    recommendationType: string | null
    priority: string | null
    description: string | null
    suggestedAction: string | null
    metadata: string | null
    createdAt: Date | null
    driverId: string | null
    vehicleId: string | null
    componentId: string | null
    tripId: string | null
  }

  export type AIRecommendationMaxAggregateOutputType = {
    id: string | null
    targetType: string | null
    targetId: string | null
    recommendationType: string | null
    priority: string | null
    description: string | null
    suggestedAction: string | null
    metadata: string | null
    createdAt: Date | null
    driverId: string | null
    vehicleId: string | null
    componentId: string | null
    tripId: string | null
  }

  export type AIRecommendationCountAggregateOutputType = {
    id: number
    targetType: number
    targetId: number
    recommendationType: number
    priority: number
    description: number
    suggestedAction: number
    metadata: number
    createdAt: number
    driverId: number
    vehicleId: number
    componentId: number
    tripId: number
    _all: number
  }


  export type AIRecommendationMinAggregateInputType = {
    id?: true
    targetType?: true
    targetId?: true
    recommendationType?: true
    priority?: true
    description?: true
    suggestedAction?: true
    metadata?: true
    createdAt?: true
    driverId?: true
    vehicleId?: true
    componentId?: true
    tripId?: true
  }

  export type AIRecommendationMaxAggregateInputType = {
    id?: true
    targetType?: true
    targetId?: true
    recommendationType?: true
    priority?: true
    description?: true
    suggestedAction?: true
    metadata?: true
    createdAt?: true
    driverId?: true
    vehicleId?: true
    componentId?: true
    tripId?: true
  }

  export type AIRecommendationCountAggregateInputType = {
    id?: true
    targetType?: true
    targetId?: true
    recommendationType?: true
    priority?: true
    description?: true
    suggestedAction?: true
    metadata?: true
    createdAt?: true
    driverId?: true
    vehicleId?: true
    componentId?: true
    tripId?: true
    _all?: true
  }

  export type AIRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRecommendation to aggregate.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIRecommendations
    **/
    _count?: true | AIRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIRecommendationMaxAggregateInputType
  }

  export type GetAIRecommendationAggregateType<T extends AIRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateAIRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIRecommendation[P]>
      : GetScalarType<T[P], AggregateAIRecommendation[P]>
  }




  export type AIRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIRecommendationWhereInput
    orderBy?: AIRecommendationOrderByWithAggregationInput | AIRecommendationOrderByWithAggregationInput[]
    by: AIRecommendationScalarFieldEnum[] | AIRecommendationScalarFieldEnum
    having?: AIRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIRecommendationCountAggregateInputType | true
    _min?: AIRecommendationMinAggregateInputType
    _max?: AIRecommendationMaxAggregateInputType
  }

  export type AIRecommendationGroupByOutputType = {
    id: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata: string | null
    createdAt: Date
    driverId: string | null
    vehicleId: string | null
    componentId: string | null
    tripId: string | null
    _count: AIRecommendationCountAggregateOutputType | null
    _min: AIRecommendationMinAggregateOutputType | null
    _max: AIRecommendationMaxAggregateOutputType | null
  }

  type GetAIRecommendationGroupByPayload<T extends AIRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], AIRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type AIRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetType?: boolean
    targetId?: boolean
    recommendationType?: boolean
    priority?: boolean
    description?: boolean
    suggestedAction?: boolean
    metadata?: boolean
    createdAt?: boolean
    driverId?: boolean
    vehicleId?: boolean
    componentId?: boolean
    tripId?: boolean
    component?: boolean | AIRecommendation$componentArgs<ExtArgs>
    driver?: boolean | AIRecommendation$driverArgs<ExtArgs>
    trip?: boolean | AIRecommendation$tripArgs<ExtArgs>
    vehicle?: boolean | AIRecommendation$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["aIRecommendation"]>



  export type AIRecommendationSelectScalar = {
    id?: boolean
    targetType?: boolean
    targetId?: boolean
    recommendationType?: boolean
    priority?: boolean
    description?: boolean
    suggestedAction?: boolean
    metadata?: boolean
    createdAt?: boolean
    driverId?: boolean
    vehicleId?: boolean
    componentId?: boolean
    tripId?: boolean
  }

  export type AIRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "targetType" | "targetId" | "recommendationType" | "priority" | "description" | "suggestedAction" | "metadata" | "createdAt" | "driverId" | "vehicleId" | "componentId" | "tripId", ExtArgs["result"]["aIRecommendation"]>
  export type AIRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | AIRecommendation$componentArgs<ExtArgs>
    driver?: boolean | AIRecommendation$driverArgs<ExtArgs>
    trip?: boolean | AIRecommendation$tripArgs<ExtArgs>
    vehicle?: boolean | AIRecommendation$vehicleArgs<ExtArgs>
  }

  export type $AIRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIRecommendation"
    objects: {
      component: Prisma.$ComponentPayload<ExtArgs> | null
      driver: Prisma.$DriverPayload<ExtArgs> | null
      trip: Prisma.$TripPayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      targetType: string
      targetId: string
      recommendationType: string
      priority: string
      description: string
      suggestedAction: string
      metadata: string | null
      createdAt: Date
      driverId: string | null
      vehicleId: string | null
      componentId: string | null
      tripId: string | null
    }, ExtArgs["result"]["aIRecommendation"]>
    composites: {}
  }

  type AIRecommendationGetPayload<S extends boolean | null | undefined | AIRecommendationDefaultArgs> = $Result.GetResult<Prisma.$AIRecommendationPayload, S>

  type AIRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIRecommendationCountAggregateInputType | true
    }

  export interface AIRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIRecommendation'], meta: { name: 'AIRecommendation' } }
    /**
     * Find zero or one AIRecommendation that matches the filter.
     * @param {AIRecommendationFindUniqueArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIRecommendationFindUniqueArgs>(args: SelectSubset<T, AIRecommendationFindUniqueArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIRecommendationFindUniqueOrThrowArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, AIRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindFirstArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIRecommendationFindFirstArgs>(args?: SelectSubset<T, AIRecommendationFindFirstArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindFirstOrThrowArgs} args - Arguments to find a AIRecommendation
     * @example
     * // Get one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, AIRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIRecommendations
     * const aIRecommendations = await prisma.aIRecommendation.findMany()
     * 
     * // Get first 10 AIRecommendations
     * const aIRecommendations = await prisma.aIRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIRecommendationWithIdOnly = await prisma.aIRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIRecommendationFindManyArgs>(args?: SelectSubset<T, AIRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIRecommendation.
     * @param {AIRecommendationCreateArgs} args - Arguments to create a AIRecommendation.
     * @example
     * // Create one AIRecommendation
     * const AIRecommendation = await prisma.aIRecommendation.create({
     *   data: {
     *     // ... data to create a AIRecommendation
     *   }
     * })
     * 
     */
    create<T extends AIRecommendationCreateArgs>(args: SelectSubset<T, AIRecommendationCreateArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIRecommendations.
     * @param {AIRecommendationCreateManyArgs} args - Arguments to create many AIRecommendations.
     * @example
     * // Create many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIRecommendationCreateManyArgs>(args?: SelectSubset<T, AIRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AIRecommendation.
     * @param {AIRecommendationDeleteArgs} args - Arguments to delete one AIRecommendation.
     * @example
     * // Delete one AIRecommendation
     * const AIRecommendation = await prisma.aIRecommendation.delete({
     *   where: {
     *     // ... filter to delete one AIRecommendation
     *   }
     * })
     * 
     */
    delete<T extends AIRecommendationDeleteArgs>(args: SelectSubset<T, AIRecommendationDeleteArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIRecommendation.
     * @param {AIRecommendationUpdateArgs} args - Arguments to update one AIRecommendation.
     * @example
     * // Update one AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIRecommendationUpdateArgs>(args: SelectSubset<T, AIRecommendationUpdateArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIRecommendations.
     * @param {AIRecommendationDeleteManyArgs} args - Arguments to filter AIRecommendations to delete.
     * @example
     * // Delete a few AIRecommendations
     * const { count } = await prisma.aIRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIRecommendationDeleteManyArgs>(args?: SelectSubset<T, AIRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIRecommendations
     * const aIRecommendation = await prisma.aIRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIRecommendationUpdateManyArgs>(args: SelectSubset<T, AIRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIRecommendation.
     * @param {AIRecommendationUpsertArgs} args - Arguments to update or create a AIRecommendation.
     * @example
     * // Update or create a AIRecommendation
     * const aIRecommendation = await prisma.aIRecommendation.upsert({
     *   create: {
     *     // ... data to create a AIRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends AIRecommendationUpsertArgs>(args: SelectSubset<T, AIRecommendationUpsertArgs<ExtArgs>>): Prisma__AIRecommendationClient<$Result.GetResult<Prisma.$AIRecommendationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationCountArgs} args - Arguments to filter AIRecommendations to count.
     * @example
     * // Count the number of AIRecommendations
     * const count = await prisma.aIRecommendation.count({
     *   where: {
     *     // ... the filter for the AIRecommendations we want to count
     *   }
     * })
    **/
    count<T extends AIRecommendationCountArgs>(
      args?: Subset<T, AIRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIRecommendationAggregateArgs>(args: Subset<T, AIRecommendationAggregateArgs>): Prisma.PrismaPromise<GetAIRecommendationAggregateType<T>>

    /**
     * Group by AIRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: AIRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIRecommendation model
   */
  readonly fields: AIRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    component<T extends AIRecommendation$componentArgs<ExtArgs> = {}>(args?: Subset<T, AIRecommendation$componentArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    driver<T extends AIRecommendation$driverArgs<ExtArgs> = {}>(args?: Subset<T, AIRecommendation$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trip<T extends AIRecommendation$tripArgs<ExtArgs> = {}>(args?: Subset<T, AIRecommendation$tripArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends AIRecommendation$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, AIRecommendation$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIRecommendation model
   */
  interface AIRecommendationFieldRefs {
    readonly id: FieldRef<"AIRecommendation", 'String'>
    readonly targetType: FieldRef<"AIRecommendation", 'String'>
    readonly targetId: FieldRef<"AIRecommendation", 'String'>
    readonly recommendationType: FieldRef<"AIRecommendation", 'String'>
    readonly priority: FieldRef<"AIRecommendation", 'String'>
    readonly description: FieldRef<"AIRecommendation", 'String'>
    readonly suggestedAction: FieldRef<"AIRecommendation", 'String'>
    readonly metadata: FieldRef<"AIRecommendation", 'String'>
    readonly createdAt: FieldRef<"AIRecommendation", 'DateTime'>
    readonly driverId: FieldRef<"AIRecommendation", 'String'>
    readonly vehicleId: FieldRef<"AIRecommendation", 'String'>
    readonly componentId: FieldRef<"AIRecommendation", 'String'>
    readonly tripId: FieldRef<"AIRecommendation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AIRecommendation findUnique
   */
  export type AIRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation findUniqueOrThrow
   */
  export type AIRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation findFirst
   */
  export type AIRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRecommendations.
     */
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation findFirstOrThrow
   */
  export type AIRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendation to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIRecommendations.
     */
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation findMany
   */
  export type AIRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AIRecommendations to fetch.
     */
    where?: AIRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIRecommendations to fetch.
     */
    orderBy?: AIRecommendationOrderByWithRelationInput | AIRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIRecommendations.
     */
    cursor?: AIRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIRecommendations.
     */
    skip?: number
    distinct?: AIRecommendationScalarFieldEnum | AIRecommendationScalarFieldEnum[]
  }

  /**
   * AIRecommendation create
   */
  export type AIRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a AIRecommendation.
     */
    data: XOR<AIRecommendationCreateInput, AIRecommendationUncheckedCreateInput>
  }

  /**
   * AIRecommendation createMany
   */
  export type AIRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIRecommendations.
     */
    data: AIRecommendationCreateManyInput | AIRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIRecommendation update
   */
  export type AIRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a AIRecommendation.
     */
    data: XOR<AIRecommendationUpdateInput, AIRecommendationUncheckedUpdateInput>
    /**
     * Choose, which AIRecommendation to update.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation updateMany
   */
  export type AIRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIRecommendations.
     */
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which AIRecommendations to update
     */
    where?: AIRecommendationWhereInput
    /**
     * Limit how many AIRecommendations to update.
     */
    limit?: number
  }

  /**
   * AIRecommendation upsert
   */
  export type AIRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the AIRecommendation to update in case it exists.
     */
    where: AIRecommendationWhereUniqueInput
    /**
     * In case the AIRecommendation found by the `where` argument doesn't exist, create a new AIRecommendation with this data.
     */
    create: XOR<AIRecommendationCreateInput, AIRecommendationUncheckedCreateInput>
    /**
     * In case the AIRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIRecommendationUpdateInput, AIRecommendationUncheckedUpdateInput>
  }

  /**
   * AIRecommendation delete
   */
  export type AIRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
    /**
     * Filter which AIRecommendation to delete.
     */
    where: AIRecommendationWhereUniqueInput
  }

  /**
   * AIRecommendation deleteMany
   */
  export type AIRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIRecommendations to delete
     */
    where?: AIRecommendationWhereInput
    /**
     * Limit how many AIRecommendations to delete.
     */
    limit?: number
  }

  /**
   * AIRecommendation.component
   */
  export type AIRecommendation$componentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
  }

  /**
   * AIRecommendation.driver
   */
  export type AIRecommendation$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * AIRecommendation.trip
   */
  export type AIRecommendation$tripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
  }

  /**
   * AIRecommendation.vehicle
   */
  export type AIRecommendation$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * AIRecommendation without action
   */
  export type AIRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIRecommendation
     */
    select?: AIRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIRecommendation
     */
    omit?: AIRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIRecommendationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiresAt: 'expiresAt',
    userId: 'userId'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    licenseNumber: 'licenseNumber',
    licenseExpiry: 'licenseExpiry',
    phoneNumber: 'phoneNumber',
    driverScore: 'driverScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    model: 'model',
    year: 'year',
    plateNumber: 'plateNumber',
    status: 'status',
    fuelType: 'fuelType',
    fuelLevel: 'fuelLevel',
    insuranceExpiry: 'insuranceExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const DriverVehicleAssignmentScalarFieldEnum: {
    driverId: 'driverId',
    vehicleId: 'vehicleId',
    assignedAt: 'assignedAt'
  };

  export type DriverVehicleAssignmentScalarFieldEnum = (typeof DriverVehicleAssignmentScalarFieldEnum)[keyof typeof DriverVehicleAssignmentScalarFieldEnum]


  export const ComponentScalarFieldEnum: {
    id: 'id',
    vehicleId: 'vehicleId',
    componentType: 'componentType',
    name: 'name',
    status: 'status',
    healthScore: 'healthScore',
    expectedLifespan: 'expectedLifespan',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComponentScalarFieldEnum = (typeof ComponentScalarFieldEnum)[keyof typeof ComponentScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    vehicleId: 'vehicleId',
    driverId: 'driverId',
    startLocation: 'startLocation',
    endLocation: 'endLocation',
    startLatitude: 'startLatitude',
    startLongitude: 'startLongitude',
    endLatitude: 'endLatitude',
    endLongitude: 'endLongitude',
    startTime: 'startTime',
    endTime: 'endTime',
    distance: 'distance',
    fuelConsumed: 'fuelConsumed',
    status: 'status',
    updatedAt: 'updatedAt'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const TripMetricScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    speed: 'speed',
    acceleration: 'acceleration',
    braking: 'braking',
    fuelConsumption: 'fuelConsumption',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt'
  };

  export type TripMetricScalarFieldEnum = (typeof TripMetricScalarFieldEnum)[keyof typeof TripMetricScalarFieldEnum]


  export const DriverEvaluationScalarFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    tripId: 'tripId',
    safetyScore: 'safetyScore',
    fuelEfficiencyScore: 'fuelEfficiencyScore',
    speedingInstances: 'speedingInstances',
    hardBrakingCount: 'hardBrakingCount',
    hardAccelerationCount: 'hardAccelerationCount',
    distractionScore: 'distractionScore',
    overallScore: 'overallScore',
    recommendations: 'recommendations',
    createdAt: 'createdAt'
  };

  export type DriverEvaluationScalarFieldEnum = (typeof DriverEvaluationScalarFieldEnum)[keyof typeof DriverEvaluationScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    vehicleId: 'vehicleId',
    componentId: 'componentId',
    message: 'message',
    actionRequired: 'actionRequired',
    createdAt: 'createdAt',
    resolvedAt: 'resolvedAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const MaintenanceScalarFieldEnum: {
    id: 'id',
    vehicleId: 'vehicleId',
    componentId: 'componentId',
    maintenanceType: 'maintenanceType',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceScalarFieldEnum = (typeof MaintenanceScalarFieldEnum)[keyof typeof MaintenanceScalarFieldEnum]


  export const AIRecommendationScalarFieldEnum: {
    id: 'id',
    targetType: 'targetType',
    targetId: 'targetId',
    recommendationType: 'recommendationType',
    priority: 'priority',
    description: 'description',
    suggestedAction: 'suggestedAction',
    metadata: 'metadata',
    createdAt: 'createdAt',
    driverId: 'driverId',
    vehicleId: 'vehicleId',
    componentId: 'componentId',
    tripId: 'tripId'
  };

  export type AIRecommendationScalarFieldEnum = (typeof AIRecommendationScalarFieldEnum)[keyof typeof AIRecommendationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RefreshTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId'
  };

  export type RefreshTokenOrderByRelevanceFieldEnum = (typeof RefreshTokenOrderByRelevanceFieldEnum)[keyof typeof RefreshTokenOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const DriverOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    licenseNumber: 'licenseNumber',
    phoneNumber: 'phoneNumber'
  };

  export type DriverOrderByRelevanceFieldEnum = (typeof DriverOrderByRelevanceFieldEnum)[keyof typeof DriverOrderByRelevanceFieldEnum]


  export const VehicleOrderByRelevanceFieldEnum: {
    id: 'id',
    model: 'model',
    plateNumber: 'plateNumber',
    status: 'status',
    fuelType: 'fuelType'
  };

  export type VehicleOrderByRelevanceFieldEnum = (typeof VehicleOrderByRelevanceFieldEnum)[keyof typeof VehicleOrderByRelevanceFieldEnum]


  export const DriverVehicleAssignmentOrderByRelevanceFieldEnum: {
    driverId: 'driverId',
    vehicleId: 'vehicleId'
  };

  export type DriverVehicleAssignmentOrderByRelevanceFieldEnum = (typeof DriverVehicleAssignmentOrderByRelevanceFieldEnum)[keyof typeof DriverVehicleAssignmentOrderByRelevanceFieldEnum]


  export const ComponentOrderByRelevanceFieldEnum: {
    id: 'id',
    vehicleId: 'vehicleId',
    componentType: 'componentType',
    name: 'name',
    status: 'status',
    metadata: 'metadata'
  };

  export type ComponentOrderByRelevanceFieldEnum = (typeof ComponentOrderByRelevanceFieldEnum)[keyof typeof ComponentOrderByRelevanceFieldEnum]


  export const TripOrderByRelevanceFieldEnum: {
    id: 'id',
    vehicleId: 'vehicleId',
    driverId: 'driverId',
    startLocation: 'startLocation',
    endLocation: 'endLocation',
    status: 'status'
  };

  export type TripOrderByRelevanceFieldEnum = (typeof TripOrderByRelevanceFieldEnum)[keyof typeof TripOrderByRelevanceFieldEnum]


  export const TripMetricOrderByRelevanceFieldEnum: {
    id: 'id',
    tripId: 'tripId'
  };

  export type TripMetricOrderByRelevanceFieldEnum = (typeof TripMetricOrderByRelevanceFieldEnum)[keyof typeof TripMetricOrderByRelevanceFieldEnum]


  export const DriverEvaluationOrderByRelevanceFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    tripId: 'tripId',
    recommendations: 'recommendations'
  };

  export type DriverEvaluationOrderByRelevanceFieldEnum = (typeof DriverEvaluationOrderByRelevanceFieldEnum)[keyof typeof DriverEvaluationOrderByRelevanceFieldEnum]


  export const AlertOrderByRelevanceFieldEnum: {
    id: 'id',
    type: 'type',
    vehicleId: 'vehicleId',
    componentId: 'componentId',
    message: 'message'
  };

  export type AlertOrderByRelevanceFieldEnum = (typeof AlertOrderByRelevanceFieldEnum)[keyof typeof AlertOrderByRelevanceFieldEnum]


  export const MaintenanceOrderByRelevanceFieldEnum: {
    id: 'id',
    vehicleId: 'vehicleId',
    componentId: 'componentId',
    maintenanceType: 'maintenanceType',
    description: 'description',
    metadata: 'metadata'
  };

  export type MaintenanceOrderByRelevanceFieldEnum = (typeof MaintenanceOrderByRelevanceFieldEnum)[keyof typeof MaintenanceOrderByRelevanceFieldEnum]


  export const AIRecommendationOrderByRelevanceFieldEnum: {
    id: 'id',
    targetType: 'targetType',
    targetId: 'targetId',
    recommendationType: 'recommendationType',
    priority: 'priority',
    description: 'description',
    suggestedAction: 'suggestedAction',
    metadata: 'metadata',
    driverId: 'driverId',
    vehicleId: 'vehicleId',
    componentId: 'componentId',
    tripId: 'tripId'
  };

  export type AIRecommendationOrderByRelevanceFieldEnum = (typeof AIRecommendationOrderByRelevanceFieldEnum)[keyof typeof AIRecommendationOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    driver?: DriverOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    userId?: StringFilter<"RefreshToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: RefreshTokenOrderByRelevanceInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    userId?: StringFilter<"RefreshToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    id?: StringFilter<"Driver"> | string
    userId?: StringFilter<"Driver"> | string
    name?: StringFilter<"Driver"> | string
    licenseNumber?: StringFilter<"Driver"> | string
    licenseExpiry?: DateTimeFilter<"Driver"> | Date | string
    phoneNumber?: StringFilter<"Driver"> | string
    driverScore?: FloatNullableFilter<"Driver"> | number | null
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
    aiRecommendations?: AIRecommendationListRelationFilter
    evaluations?: DriverEvaluationListRelationFilter
    assignedVehicles?: DriverVehicleAssignmentListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    trips?: TripListRelationFilter
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    phoneNumber?: SortOrder
    driverScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiRecommendations?: AIRecommendationOrderByRelationAggregateInput
    evaluations?: DriverEvaluationOrderByRelationAggregateInput
    assignedVehicles?: DriverVehicleAssignmentOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    trips?: TripOrderByRelationAggregateInput
    _relevance?: DriverOrderByRelevanceInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    name?: StringFilter<"Driver"> | string
    licenseNumber?: StringFilter<"Driver"> | string
    licenseExpiry?: DateTimeFilter<"Driver"> | Date | string
    phoneNumber?: StringFilter<"Driver"> | string
    driverScore?: FloatNullableFilter<"Driver"> | number | null
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
    aiRecommendations?: AIRecommendationListRelationFilter
    evaluations?: DriverEvaluationListRelationFilter
    assignedVehicles?: DriverVehicleAssignmentListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    trips?: TripListRelationFilter
  }, "id" | "userId">

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    phoneNumber?: SortOrder
    driverScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _avg?: DriverAvgOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
    _sum?: DriverSumOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Driver"> | string
    userId?: StringWithAggregatesFilter<"Driver"> | string
    name?: StringWithAggregatesFilter<"Driver"> | string
    licenseNumber?: StringWithAggregatesFilter<"Driver"> | string
    licenseExpiry?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    phoneNumber?: StringWithAggregatesFilter<"Driver"> | string
    driverScore?: FloatNullableWithAggregatesFilter<"Driver"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    plateNumber?: StringFilter<"Vehicle"> | string
    status?: StringFilter<"Vehicle"> | string
    fuelType?: StringFilter<"Vehicle"> | string
    fuelLevel?: FloatFilter<"Vehicle"> | number
    insuranceExpiry?: DateTimeFilter<"Vehicle"> | Date | string
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    aiRecommendations?: AIRecommendationListRelationFilter
    alerts?: AlertListRelationFilter
    components?: ComponentListRelationFilter
    assignedDrivers?: DriverVehicleAssignmentListRelationFilter
    maintenance?: MaintenanceListRelationFilter
    trips?: TripListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    status?: SortOrder
    fuelType?: SortOrder
    fuelLevel?: SortOrder
    insuranceExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiRecommendations?: AIRecommendationOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    components?: ComponentOrderByRelationAggregateInput
    assignedDrivers?: DriverVehicleAssignmentOrderByRelationAggregateInput
    maintenance?: MaintenanceOrderByRelationAggregateInput
    trips?: TripOrderByRelationAggregateInput
    _relevance?: VehicleOrderByRelevanceInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    plateNumber?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    status?: StringFilter<"Vehicle"> | string
    fuelType?: StringFilter<"Vehicle"> | string
    fuelLevel?: FloatFilter<"Vehicle"> | number
    insuranceExpiry?: DateTimeFilter<"Vehicle"> | Date | string
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    aiRecommendations?: AIRecommendationListRelationFilter
    alerts?: AlertListRelationFilter
    components?: ComponentListRelationFilter
    assignedDrivers?: DriverVehicleAssignmentListRelationFilter
    maintenance?: MaintenanceListRelationFilter
    trips?: TripListRelationFilter
  }, "id" | "plateNumber">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    status?: SortOrder
    fuelType?: SortOrder
    fuelLevel?: SortOrder
    insuranceExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicle"> | string
    model?: StringWithAggregatesFilter<"Vehicle"> | string
    year?: IntWithAggregatesFilter<"Vehicle"> | number
    plateNumber?: StringWithAggregatesFilter<"Vehicle"> | string
    status?: StringWithAggregatesFilter<"Vehicle"> | string
    fuelType?: StringWithAggregatesFilter<"Vehicle"> | string
    fuelLevel?: FloatWithAggregatesFilter<"Vehicle"> | number
    insuranceExpiry?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
  }

  export type DriverVehicleAssignmentWhereInput = {
    AND?: DriverVehicleAssignmentWhereInput | DriverVehicleAssignmentWhereInput[]
    OR?: DriverVehicleAssignmentWhereInput[]
    NOT?: DriverVehicleAssignmentWhereInput | DriverVehicleAssignmentWhereInput[]
    driverId?: StringFilter<"DriverVehicleAssignment"> | string
    vehicleId?: StringFilter<"DriverVehicleAssignment"> | string
    assignedAt?: DateTimeFilter<"DriverVehicleAssignment"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }

  export type DriverVehicleAssignmentOrderByWithRelationInput = {
    driverId?: SortOrder
    vehicleId?: SortOrder
    assignedAt?: SortOrder
    driver?: DriverOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    _relevance?: DriverVehicleAssignmentOrderByRelevanceInput
  }

  export type DriverVehicleAssignmentWhereUniqueInput = Prisma.AtLeast<{
    driverId_vehicleId?: DriverVehicleAssignmentDriverIdVehicleIdCompoundUniqueInput
    AND?: DriverVehicleAssignmentWhereInput | DriverVehicleAssignmentWhereInput[]
    OR?: DriverVehicleAssignmentWhereInput[]
    NOT?: DriverVehicleAssignmentWhereInput | DriverVehicleAssignmentWhereInput[]
    driverId?: StringFilter<"DriverVehicleAssignment"> | string
    vehicleId?: StringFilter<"DriverVehicleAssignment"> | string
    assignedAt?: DateTimeFilter<"DriverVehicleAssignment"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }, "driverId_vehicleId">

  export type DriverVehicleAssignmentOrderByWithAggregationInput = {
    driverId?: SortOrder
    vehicleId?: SortOrder
    assignedAt?: SortOrder
    _count?: DriverVehicleAssignmentCountOrderByAggregateInput
    _max?: DriverVehicleAssignmentMaxOrderByAggregateInput
    _min?: DriverVehicleAssignmentMinOrderByAggregateInput
  }

  export type DriverVehicleAssignmentScalarWhereWithAggregatesInput = {
    AND?: DriverVehicleAssignmentScalarWhereWithAggregatesInput | DriverVehicleAssignmentScalarWhereWithAggregatesInput[]
    OR?: DriverVehicleAssignmentScalarWhereWithAggregatesInput[]
    NOT?: DriverVehicleAssignmentScalarWhereWithAggregatesInput | DriverVehicleAssignmentScalarWhereWithAggregatesInput[]
    driverId?: StringWithAggregatesFilter<"DriverVehicleAssignment"> | string
    vehicleId?: StringWithAggregatesFilter<"DriverVehicleAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"DriverVehicleAssignment"> | Date | string
  }

  export type ComponentWhereInput = {
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    id?: StringFilter<"Component"> | string
    vehicleId?: StringFilter<"Component"> | string
    componentType?: StringFilter<"Component"> | string
    name?: StringFilter<"Component"> | string
    status?: StringFilter<"Component"> | string
    healthScore?: FloatFilter<"Component"> | number
    expectedLifespan?: IntFilter<"Component"> | number
    metadata?: StringNullableFilter<"Component"> | string | null
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
    aiRecommendations?: AIRecommendationListRelationFilter
    alerts?: AlertListRelationFilter
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
    maintenance?: MaintenanceListRelationFilter
  }

  export type ComponentOrderByWithRelationInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentType?: SortOrder
    name?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    expectedLifespan?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiRecommendations?: AIRecommendationOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    vehicle?: VehicleOrderByWithRelationInput
    maintenance?: MaintenanceOrderByRelationAggregateInput
    _relevance?: ComponentOrderByRelevanceInput
  }

  export type ComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    vehicleId?: StringFilter<"Component"> | string
    componentType?: StringFilter<"Component"> | string
    name?: StringFilter<"Component"> | string
    status?: StringFilter<"Component"> | string
    healthScore?: FloatFilter<"Component"> | number
    expectedLifespan?: IntFilter<"Component"> | number
    metadata?: StringNullableFilter<"Component"> | string | null
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
    aiRecommendations?: AIRecommendationListRelationFilter
    alerts?: AlertListRelationFilter
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
    maintenance?: MaintenanceListRelationFilter
  }, "id">

  export type ComponentOrderByWithAggregationInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentType?: SortOrder
    name?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    expectedLifespan?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComponentCountOrderByAggregateInput
    _avg?: ComponentAvgOrderByAggregateInput
    _max?: ComponentMaxOrderByAggregateInput
    _min?: ComponentMinOrderByAggregateInput
    _sum?: ComponentSumOrderByAggregateInput
  }

  export type ComponentScalarWhereWithAggregatesInput = {
    AND?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    OR?: ComponentScalarWhereWithAggregatesInput[]
    NOT?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Component"> | string
    vehicleId?: StringWithAggregatesFilter<"Component"> | string
    componentType?: StringWithAggregatesFilter<"Component"> | string
    name?: StringWithAggregatesFilter<"Component"> | string
    status?: StringWithAggregatesFilter<"Component"> | string
    healthScore?: FloatWithAggregatesFilter<"Component"> | number
    expectedLifespan?: IntWithAggregatesFilter<"Component"> | number
    metadata?: StringNullableWithAggregatesFilter<"Component"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Component"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Component"> | Date | string
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: StringFilter<"Trip"> | string
    vehicleId?: StringFilter<"Trip"> | string
    driverId?: StringFilter<"Trip"> | string
    startLocation?: StringNullableFilter<"Trip"> | string | null
    endLocation?: StringNullableFilter<"Trip"> | string | null
    startLatitude?: FloatNullableFilter<"Trip"> | number | null
    startLongitude?: FloatNullableFilter<"Trip"> | number | null
    endLatitude?: FloatNullableFilter<"Trip"> | number | null
    endLongitude?: FloatNullableFilter<"Trip"> | number | null
    startTime?: DateTimeFilter<"Trip"> | Date | string
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    distance?: FloatNullableFilter<"Trip"> | number | null
    fuelConsumed?: FloatNullableFilter<"Trip"> | number | null
    status?: StringFilter<"Trip"> | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    aiRecommendations?: AIRecommendationListRelationFilter
    evaluation?: XOR<DriverEvaluationNullableScalarRelationFilter, DriverEvaluationWhereInput> | null
    metrics?: TripMetricListRelationFilter
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    startLocation?: SortOrderInput | SortOrder
    endLocation?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    fuelConsumed?: SortOrderInput | SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    aiRecommendations?: AIRecommendationOrderByRelationAggregateInput
    evaluation?: DriverEvaluationOrderByWithRelationInput
    metrics?: TripMetricOrderByRelationAggregateInput
    driver?: DriverOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    _relevance?: TripOrderByRelevanceInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    vehicleId?: StringFilter<"Trip"> | string
    driverId?: StringFilter<"Trip"> | string
    startLocation?: StringNullableFilter<"Trip"> | string | null
    endLocation?: StringNullableFilter<"Trip"> | string | null
    startLatitude?: FloatNullableFilter<"Trip"> | number | null
    startLongitude?: FloatNullableFilter<"Trip"> | number | null
    endLatitude?: FloatNullableFilter<"Trip"> | number | null
    endLongitude?: FloatNullableFilter<"Trip"> | number | null
    startTime?: DateTimeFilter<"Trip"> | Date | string
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    distance?: FloatNullableFilter<"Trip"> | number | null
    fuelConsumed?: FloatNullableFilter<"Trip"> | number | null
    status?: StringFilter<"Trip"> | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    aiRecommendations?: AIRecommendationListRelationFilter
    evaluation?: XOR<DriverEvaluationNullableScalarRelationFilter, DriverEvaluationWhereInput> | null
    metrics?: TripMetricListRelationFilter
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }, "id">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    startLocation?: SortOrderInput | SortOrder
    endLocation?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    fuelConsumed?: SortOrderInput | SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    _count?: TripCountOrderByAggregateInput
    _avg?: TripAvgOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
    _sum?: TripSumOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trip"> | string
    vehicleId?: StringWithAggregatesFilter<"Trip"> | string
    driverId?: StringWithAggregatesFilter<"Trip"> | string
    startLocation?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    endLocation?: StringNullableWithAggregatesFilter<"Trip"> | string | null
    startLatitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    startLongitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    endLatitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    endLongitude?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    startTime?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    distance?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    fuelConsumed?: FloatNullableWithAggregatesFilter<"Trip"> | number | null
    status?: StringWithAggregatesFilter<"Trip"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
  }

  export type TripMetricWhereInput = {
    AND?: TripMetricWhereInput | TripMetricWhereInput[]
    OR?: TripMetricWhereInput[]
    NOT?: TripMetricWhereInput | TripMetricWhereInput[]
    id?: StringFilter<"TripMetric"> | string
    tripId?: StringFilter<"TripMetric"> | string
    speed?: FloatNullableFilter<"TripMetric"> | number | null
    acceleration?: FloatNullableFilter<"TripMetric"> | number | null
    braking?: FloatNullableFilter<"TripMetric"> | number | null
    fuelConsumption?: FloatNullableFilter<"TripMetric"> | number | null
    latitude?: FloatNullableFilter<"TripMetric"> | number | null
    longitude?: FloatNullableFilter<"TripMetric"> | number | null
    createdAt?: DateTimeFilter<"TripMetric"> | Date | string
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }

  export type TripMetricOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    speed?: SortOrderInput | SortOrder
    acceleration?: SortOrderInput | SortOrder
    braking?: SortOrderInput | SortOrder
    fuelConsumption?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    trip?: TripOrderByWithRelationInput
    _relevance?: TripMetricOrderByRelevanceInput
  }

  export type TripMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripMetricWhereInput | TripMetricWhereInput[]
    OR?: TripMetricWhereInput[]
    NOT?: TripMetricWhereInput | TripMetricWhereInput[]
    tripId?: StringFilter<"TripMetric"> | string
    speed?: FloatNullableFilter<"TripMetric"> | number | null
    acceleration?: FloatNullableFilter<"TripMetric"> | number | null
    braking?: FloatNullableFilter<"TripMetric"> | number | null
    fuelConsumption?: FloatNullableFilter<"TripMetric"> | number | null
    latitude?: FloatNullableFilter<"TripMetric"> | number | null
    longitude?: FloatNullableFilter<"TripMetric"> | number | null
    createdAt?: DateTimeFilter<"TripMetric"> | Date | string
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }, "id">

  export type TripMetricOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    speed?: SortOrderInput | SortOrder
    acceleration?: SortOrderInput | SortOrder
    braking?: SortOrderInput | SortOrder
    fuelConsumption?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TripMetricCountOrderByAggregateInput
    _avg?: TripMetricAvgOrderByAggregateInput
    _max?: TripMetricMaxOrderByAggregateInput
    _min?: TripMetricMinOrderByAggregateInput
    _sum?: TripMetricSumOrderByAggregateInput
  }

  export type TripMetricScalarWhereWithAggregatesInput = {
    AND?: TripMetricScalarWhereWithAggregatesInput | TripMetricScalarWhereWithAggregatesInput[]
    OR?: TripMetricScalarWhereWithAggregatesInput[]
    NOT?: TripMetricScalarWhereWithAggregatesInput | TripMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripMetric"> | string
    tripId?: StringWithAggregatesFilter<"TripMetric"> | string
    speed?: FloatNullableWithAggregatesFilter<"TripMetric"> | number | null
    acceleration?: FloatNullableWithAggregatesFilter<"TripMetric"> | number | null
    braking?: FloatNullableWithAggregatesFilter<"TripMetric"> | number | null
    fuelConsumption?: FloatNullableWithAggregatesFilter<"TripMetric"> | number | null
    latitude?: FloatNullableWithAggregatesFilter<"TripMetric"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"TripMetric"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TripMetric"> | Date | string
  }

  export type DriverEvaluationWhereInput = {
    AND?: DriverEvaluationWhereInput | DriverEvaluationWhereInput[]
    OR?: DriverEvaluationWhereInput[]
    NOT?: DriverEvaluationWhereInput | DriverEvaluationWhereInput[]
    id?: StringFilter<"DriverEvaluation"> | string
    driverId?: StringFilter<"DriverEvaluation"> | string
    tripId?: StringFilter<"DriverEvaluation"> | string
    safetyScore?: FloatFilter<"DriverEvaluation"> | number
    fuelEfficiencyScore?: FloatFilter<"DriverEvaluation"> | number
    speedingInstances?: IntFilter<"DriverEvaluation"> | number
    hardBrakingCount?: IntFilter<"DriverEvaluation"> | number
    hardAccelerationCount?: IntFilter<"DriverEvaluation"> | number
    distractionScore?: FloatFilter<"DriverEvaluation"> | number
    overallScore?: FloatFilter<"DriverEvaluation"> | number
    recommendations?: StringNullableFilter<"DriverEvaluation"> | string | null
    createdAt?: DateTimeFilter<"DriverEvaluation"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }

  export type DriverEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    driverId?: SortOrder
    tripId?: SortOrder
    safetyScore?: SortOrder
    fuelEfficiencyScore?: SortOrder
    speedingInstances?: SortOrder
    hardBrakingCount?: SortOrder
    hardAccelerationCount?: SortOrder
    distractionScore?: SortOrder
    overallScore?: SortOrder
    recommendations?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    driver?: DriverOrderByWithRelationInput
    trip?: TripOrderByWithRelationInput
    _relevance?: DriverEvaluationOrderByRelevanceInput
  }

  export type DriverEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tripId?: string
    AND?: DriverEvaluationWhereInput | DriverEvaluationWhereInput[]
    OR?: DriverEvaluationWhereInput[]
    NOT?: DriverEvaluationWhereInput | DriverEvaluationWhereInput[]
    driverId?: StringFilter<"DriverEvaluation"> | string
    safetyScore?: FloatFilter<"DriverEvaluation"> | number
    fuelEfficiencyScore?: FloatFilter<"DriverEvaluation"> | number
    speedingInstances?: IntFilter<"DriverEvaluation"> | number
    hardBrakingCount?: IntFilter<"DriverEvaluation"> | number
    hardAccelerationCount?: IntFilter<"DriverEvaluation"> | number
    distractionScore?: FloatFilter<"DriverEvaluation"> | number
    overallScore?: FloatFilter<"DriverEvaluation"> | number
    recommendations?: StringNullableFilter<"DriverEvaluation"> | string | null
    createdAt?: DateTimeFilter<"DriverEvaluation"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
  }, "id" | "tripId">

  export type DriverEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    driverId?: SortOrder
    tripId?: SortOrder
    safetyScore?: SortOrder
    fuelEfficiencyScore?: SortOrder
    speedingInstances?: SortOrder
    hardBrakingCount?: SortOrder
    hardAccelerationCount?: SortOrder
    distractionScore?: SortOrder
    overallScore?: SortOrder
    recommendations?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DriverEvaluationCountOrderByAggregateInput
    _avg?: DriverEvaluationAvgOrderByAggregateInput
    _max?: DriverEvaluationMaxOrderByAggregateInput
    _min?: DriverEvaluationMinOrderByAggregateInput
    _sum?: DriverEvaluationSumOrderByAggregateInput
  }

  export type DriverEvaluationScalarWhereWithAggregatesInput = {
    AND?: DriverEvaluationScalarWhereWithAggregatesInput | DriverEvaluationScalarWhereWithAggregatesInput[]
    OR?: DriverEvaluationScalarWhereWithAggregatesInput[]
    NOT?: DriverEvaluationScalarWhereWithAggregatesInput | DriverEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DriverEvaluation"> | string
    driverId?: StringWithAggregatesFilter<"DriverEvaluation"> | string
    tripId?: StringWithAggregatesFilter<"DriverEvaluation"> | string
    safetyScore?: FloatWithAggregatesFilter<"DriverEvaluation"> | number
    fuelEfficiencyScore?: FloatWithAggregatesFilter<"DriverEvaluation"> | number
    speedingInstances?: IntWithAggregatesFilter<"DriverEvaluation"> | number
    hardBrakingCount?: IntWithAggregatesFilter<"DriverEvaluation"> | number
    hardAccelerationCount?: IntWithAggregatesFilter<"DriverEvaluation"> | number
    distractionScore?: FloatWithAggregatesFilter<"DriverEvaluation"> | number
    overallScore?: FloatWithAggregatesFilter<"DriverEvaluation"> | number
    recommendations?: StringNullableWithAggregatesFilter<"DriverEvaluation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DriverEvaluation"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    type?: StringFilter<"Alert"> | string
    vehicleId?: StringFilter<"Alert"> | string
    componentId?: StringNullableFilter<"Alert"> | string | null
    message?: StringFilter<"Alert"> | string
    actionRequired?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    component?: XOR<ComponentNullableScalarRelationFilter, ComponentWhereInput> | null
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrderInput | SortOrder
    message?: SortOrder
    actionRequired?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    _relevance?: AlertOrderByRelevanceInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    type?: StringFilter<"Alert"> | string
    vehicleId?: StringFilter<"Alert"> | string
    componentId?: StringNullableFilter<"Alert"> | string | null
    message?: StringFilter<"Alert"> | string
    actionRequired?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    component?: XOR<ComponentNullableScalarRelationFilter, ComponentWhereInput> | null
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrderInput | SortOrder
    message?: SortOrder
    actionRequired?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    type?: StringWithAggregatesFilter<"Alert"> | string
    vehicleId?: StringWithAggregatesFilter<"Alert"> | string
    componentId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    message?: StringWithAggregatesFilter<"Alert"> | string
    actionRequired?: BoolWithAggregatesFilter<"Alert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
  }

  export type MaintenanceWhereInput = {
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    vehicleId?: StringFilter<"Maintenance"> | string
    componentId?: StringNullableFilter<"Maintenance"> | string | null
    maintenanceType?: StringFilter<"Maintenance"> | string
    description?: StringFilter<"Maintenance"> | string
    metadata?: StringNullableFilter<"Maintenance"> | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    component?: XOR<ComponentNullableScalarRelationFilter, ComponentWhereInput> | null
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }

  export type MaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrderInput | SortOrder
    maintenanceType?: SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    component?: ComponentOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    _relevance?: MaintenanceOrderByRelevanceInput
  }

  export type MaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    vehicleId?: StringFilter<"Maintenance"> | string
    componentId?: StringNullableFilter<"Maintenance"> | string | null
    maintenanceType?: StringFilter<"Maintenance"> | string
    description?: StringFilter<"Maintenance"> | string
    metadata?: StringNullableFilter<"Maintenance"> | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    component?: XOR<ComponentNullableScalarRelationFilter, ComponentWhereInput> | null
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }, "id">

  export type MaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrderInput | SortOrder
    maintenanceType?: SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceCountOrderByAggregateInput
    _max?: MaintenanceMaxOrderByAggregateInput
    _min?: MaintenanceMinOrderByAggregateInput
  }

  export type MaintenanceScalarWhereWithAggregatesInput = {
    AND?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    OR?: MaintenanceScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Maintenance"> | string
    vehicleId?: StringWithAggregatesFilter<"Maintenance"> | string
    componentId?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    maintenanceType?: StringWithAggregatesFilter<"Maintenance"> | string
    description?: StringWithAggregatesFilter<"Maintenance"> | string
    metadata?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
  }

  export type AIRecommendationWhereInput = {
    AND?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    OR?: AIRecommendationWhereInput[]
    NOT?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    id?: StringFilter<"AIRecommendation"> | string
    targetType?: StringFilter<"AIRecommendation"> | string
    targetId?: StringFilter<"AIRecommendation"> | string
    recommendationType?: StringFilter<"AIRecommendation"> | string
    priority?: StringFilter<"AIRecommendation"> | string
    description?: StringFilter<"AIRecommendation"> | string
    suggestedAction?: StringFilter<"AIRecommendation"> | string
    metadata?: StringNullableFilter<"AIRecommendation"> | string | null
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
    driverId?: StringNullableFilter<"AIRecommendation"> | string | null
    vehicleId?: StringNullableFilter<"AIRecommendation"> | string | null
    componentId?: StringNullableFilter<"AIRecommendation"> | string | null
    tripId?: StringNullableFilter<"AIRecommendation"> | string | null
    component?: XOR<ComponentNullableScalarRelationFilter, ComponentWhereInput> | null
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    trip?: XOR<TripNullableScalarRelationFilter, TripWhereInput> | null
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
  }

  export type AIRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    recommendationType?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    suggestedAction?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    driverId?: SortOrderInput | SortOrder
    vehicleId?: SortOrderInput | SortOrder
    componentId?: SortOrderInput | SortOrder
    tripId?: SortOrderInput | SortOrder
    component?: ComponentOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
    trip?: TripOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    _relevance?: AIRecommendationOrderByRelevanceInput
  }

  export type AIRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    OR?: AIRecommendationWhereInput[]
    NOT?: AIRecommendationWhereInput | AIRecommendationWhereInput[]
    targetType?: StringFilter<"AIRecommendation"> | string
    targetId?: StringFilter<"AIRecommendation"> | string
    recommendationType?: StringFilter<"AIRecommendation"> | string
    priority?: StringFilter<"AIRecommendation"> | string
    description?: StringFilter<"AIRecommendation"> | string
    suggestedAction?: StringFilter<"AIRecommendation"> | string
    metadata?: StringNullableFilter<"AIRecommendation"> | string | null
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
    driverId?: StringNullableFilter<"AIRecommendation"> | string | null
    vehicleId?: StringNullableFilter<"AIRecommendation"> | string | null
    componentId?: StringNullableFilter<"AIRecommendation"> | string | null
    tripId?: StringNullableFilter<"AIRecommendation"> | string | null
    component?: XOR<ComponentNullableScalarRelationFilter, ComponentWhereInput> | null
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    trip?: XOR<TripNullableScalarRelationFilter, TripWhereInput> | null
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
  }, "id">

  export type AIRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    recommendationType?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    suggestedAction?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    driverId?: SortOrderInput | SortOrder
    vehicleId?: SortOrderInput | SortOrder
    componentId?: SortOrderInput | SortOrder
    tripId?: SortOrderInput | SortOrder
    _count?: AIRecommendationCountOrderByAggregateInput
    _max?: AIRecommendationMaxOrderByAggregateInput
    _min?: AIRecommendationMinOrderByAggregateInput
  }

  export type AIRecommendationScalarWhereWithAggregatesInput = {
    AND?: AIRecommendationScalarWhereWithAggregatesInput | AIRecommendationScalarWhereWithAggregatesInput[]
    OR?: AIRecommendationScalarWhereWithAggregatesInput[]
    NOT?: AIRecommendationScalarWhereWithAggregatesInput | AIRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIRecommendation"> | string
    targetType?: StringWithAggregatesFilter<"AIRecommendation"> | string
    targetId?: StringWithAggregatesFilter<"AIRecommendation"> | string
    recommendationType?: StringWithAggregatesFilter<"AIRecommendation"> | string
    priority?: StringWithAggregatesFilter<"AIRecommendation"> | string
    description?: StringWithAggregatesFilter<"AIRecommendation"> | string
    suggestedAction?: StringWithAggregatesFilter<"AIRecommendation"> | string
    metadata?: StringNullableWithAggregatesFilter<"AIRecommendation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIRecommendation"> | Date | string
    driverId?: StringNullableWithAggregatesFilter<"AIRecommendation"> | string | null
    vehicleId?: StringNullableWithAggregatesFilter<"AIRecommendation"> | string | null
    componentId?: StringNullableWithAggregatesFilter<"AIRecommendation"> | string | null
    tripId?: StringNullableWithAggregatesFilter<"AIRecommendation"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    driver?: DriverCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    userId: string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    expiresAt: Date | string
    userId: string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DriverCreateInput = {
    id?: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutDriverInput
    evaluations?: DriverEvaluationCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutDriverInput
    evaluations?: DriverEvaluationUncheckedCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutDriverNestedInput
    evaluations?: DriverEvaluationUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutDriverNestedInput
    evaluations?: DriverEvaluationUncheckedUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverCreateManyInput = {
    id?: string
    userId: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutVehicleInput
    alerts?: AlertCreateNestedManyWithoutVehicleInput
    components?: ComponentCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceCreateNestedManyWithoutVehicleInput
    trips?: TripCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutVehicleInput
    alerts?: AlertUncheckedCreateNestedManyWithoutVehicleInput
    components?: ComponentUncheckedCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutVehicleInput
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUpdateManyWithoutVehicleNestedInput
    components?: ComponentUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUpdateManyWithoutVehicleNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutVehicleNestedInput
    components?: ComponentUncheckedUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutVehicleNestedInput
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleAssignmentCreateInput = {
    assignedAt?: Date | string
    driver: DriverCreateNestedOneWithoutAssignedVehiclesInput
    vehicle: VehicleCreateNestedOneWithoutAssignedDriversInput
  }

  export type DriverVehicleAssignmentUncheckedCreateInput = {
    driverId: string
    vehicleId: string
    assignedAt?: Date | string
  }

  export type DriverVehicleAssignmentUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutAssignedVehiclesNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutAssignedDriversNestedInput
  }

  export type DriverVehicleAssignmentUncheckedUpdateInput = {
    driverId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleAssignmentCreateManyInput = {
    driverId: string
    vehicleId: string
    assignedAt?: Date | string
  }

  export type DriverVehicleAssignmentUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleAssignmentUncheckedUpdateManyInput = {
    driverId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentCreateInput = {
    id?: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutComponentInput
    alerts?: AlertCreateNestedManyWithoutComponentInput
    vehicle: VehicleCreateNestedOneWithoutComponentsInput
    maintenance?: MaintenanceCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateInput = {
    id?: string
    vehicleId: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutComponentInput
    alerts?: AlertUncheckedCreateNestedManyWithoutComponentInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutComponentNestedInput
    alerts?: AlertUpdateManyWithoutComponentNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutComponentsNestedInput
    maintenance?: MaintenanceUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutComponentNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutComponentNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type ComponentCreateManyInput = {
    id?: string
    vehicleId: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateInput = {
    id?: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutTripInput
    evaluation?: DriverEvaluationCreateNestedOneWithoutTripInput
    metrics?: TripMetricCreateNestedManyWithoutTripInput
    driver: DriverCreateNestedOneWithoutTripsInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateInput = {
    id?: string
    vehicleId: string
    driverId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutTripInput
    evaluation?: DriverEvaluationUncheckedCreateNestedOneWithoutTripInput
    metrics?: TripMetricUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutTripNestedInput
    evaluation?: DriverEvaluationUpdateOneWithoutTripNestedInput
    metrics?: TripMetricUpdateManyWithoutTripNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutTripNestedInput
    evaluation?: DriverEvaluationUncheckedUpdateOneWithoutTripNestedInput
    metrics?: TripMetricUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateManyInput = {
    id?: string
    vehicleId: string
    driverId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
  }

  export type TripUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMetricCreateInput = {
    id?: string
    speed?: number | null
    acceleration?: number | null
    braking?: number | null
    fuelConsumption?: number | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutMetricsInput
  }

  export type TripMetricUncheckedCreateInput = {
    id?: string
    tripId: string
    speed?: number | null
    acceleration?: number | null
    braking?: number | null
    fuelConsumption?: number | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
  }

  export type TripMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    braking?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumption?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type TripMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    braking?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumption?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMetricCreateManyInput = {
    id?: string
    tripId: string
    speed?: number | null
    acceleration?: number | null
    braking?: number | null
    fuelConsumption?: number | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
  }

  export type TripMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    braking?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumption?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    braking?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumption?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverEvaluationCreateInput = {
    id?: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations?: string | null
    createdAt?: Date | string
    driver: DriverCreateNestedOneWithoutEvaluationsInput
    trip: TripCreateNestedOneWithoutEvaluationInput
  }

  export type DriverEvaluationUncheckedCreateInput = {
    id?: string
    driverId: string
    tripId: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations?: string | null
    createdAt?: Date | string
  }

  export type DriverEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutEvaluationsNestedInput
    trip?: TripUpdateOneRequiredWithoutEvaluationNestedInput
  }

  export type DriverEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverEvaluationCreateManyInput = {
    id?: string
    driverId: string
    tripId: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations?: string | null
    createdAt?: Date | string
  }

  export type DriverEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    type: string
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    component?: ComponentCreateNestedOneWithoutAlertsInput
    vehicle: VehicleCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    type: string
    vehicleId: string
    componentId?: string | null
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneWithoutAlertsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertCreateManyInput = {
    id?: string
    type: string
    vehicleId: string
    componentId?: string | null
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceCreateInput = {
    id?: string
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    component?: ComponentCreateNestedOneWithoutMaintenanceInput
    vehicle: VehicleCreateNestedOneWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateInput = {
    id?: string
    vehicleId: string
    componentId?: string | null
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: ComponentUpdateOneWithoutMaintenanceNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceCreateManyInput = {
    id?: string
    vehicleId: string
    componentId?: string | null
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationCreateInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    component?: ComponentCreateNestedOneWithoutAiRecommendationsInput
    driver?: DriverCreateNestedOneWithoutAiRecommendationsInput
    trip?: TripCreateNestedOneWithoutAiRecommendationsInput
    vehicle?: VehicleCreateNestedOneWithoutAiRecommendationsInput
  }

  export type AIRecommendationUncheckedCreateInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driverId?: string | null
    vehicleId?: string | null
    componentId?: string | null
    tripId?: string | null
  }

  export type AIRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: ComponentUpdateOneWithoutAiRecommendationsNestedInput
    driver?: DriverUpdateOneWithoutAiRecommendationsNestedInput
    trip?: TripUpdateOneWithoutAiRecommendationsNestedInput
    vehicle?: VehicleUpdateOneWithoutAiRecommendationsNestedInput
  }

  export type AIRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIRecommendationCreateManyInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driverId?: string | null
    vehicleId?: string | null
    componentId?: string | null
    tripId?: string | null
  }

  export type AIRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DriverNullableScalarRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenOrderByRelevanceInput = {
    fields: RefreshTokenOrderByRelevanceFieldEnum | RefreshTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AIRecommendationListRelationFilter = {
    every?: AIRecommendationWhereInput
    some?: AIRecommendationWhereInput
    none?: AIRecommendationWhereInput
  }

  export type DriverEvaluationListRelationFilter = {
    every?: DriverEvaluationWhereInput
    some?: DriverEvaluationWhereInput
    none?: DriverEvaluationWhereInput
  }

  export type DriverVehicleAssignmentListRelationFilter = {
    every?: DriverVehicleAssignmentWhereInput
    some?: DriverVehicleAssignmentWhereInput
    none?: DriverVehicleAssignmentWhereInput
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AIRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverVehicleAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverOrderByRelevanceInput = {
    fields: DriverOrderByRelevanceFieldEnum | DriverOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    phoneNumber?: SortOrder
    driverScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverAvgOrderByAggregateInput = {
    driverScore?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    phoneNumber?: SortOrder
    driverScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrder
    licenseExpiry?: SortOrder
    phoneNumber?: SortOrder
    driverScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverSumOrderByAggregateInput = {
    driverScore?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type ComponentListRelationFilter = {
    every?: ComponentWhereInput
    some?: ComponentWhereInput
    none?: ComponentWhereInput
  }

  export type MaintenanceListRelationFilter = {
    every?: MaintenanceWhereInput
    some?: MaintenanceWhereInput
    none?: MaintenanceWhereInput
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleOrderByRelevanceInput = {
    fields: VehicleOrderByRelevanceFieldEnum | VehicleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    status?: SortOrder
    fuelType?: SortOrder
    fuelLevel?: SortOrder
    insuranceExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    year?: SortOrder
    fuelLevel?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    status?: SortOrder
    fuelType?: SortOrder
    fuelLevel?: SortOrder
    insuranceExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    status?: SortOrder
    fuelType?: SortOrder
    fuelLevel?: SortOrder
    insuranceExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    year?: SortOrder
    fuelLevel?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DriverScalarRelationFilter = {
    is?: DriverWhereInput
    isNot?: DriverWhereInput
  }

  export type VehicleScalarRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type DriverVehicleAssignmentOrderByRelevanceInput = {
    fields: DriverVehicleAssignmentOrderByRelevanceFieldEnum | DriverVehicleAssignmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DriverVehicleAssignmentDriverIdVehicleIdCompoundUniqueInput = {
    driverId: string
    vehicleId: string
  }

  export type DriverVehicleAssignmentCountOrderByAggregateInput = {
    driverId?: SortOrder
    vehicleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type DriverVehicleAssignmentMaxOrderByAggregateInput = {
    driverId?: SortOrder
    vehicleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type DriverVehicleAssignmentMinOrderByAggregateInput = {
    driverId?: SortOrder
    vehicleId?: SortOrder
    assignedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ComponentOrderByRelevanceInput = {
    fields: ComponentOrderByRelevanceFieldEnum | ComponentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComponentCountOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentType?: SortOrder
    name?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    expectedLifespan?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentAvgOrderByAggregateInput = {
    healthScore?: SortOrder
    expectedLifespan?: SortOrder
  }

  export type ComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentType?: SortOrder
    name?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    expectedLifespan?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentMinOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentType?: SortOrder
    name?: SortOrder
    status?: SortOrder
    healthScore?: SortOrder
    expectedLifespan?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComponentSumOrderByAggregateInput = {
    healthScore?: SortOrder
    expectedLifespan?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DriverEvaluationNullableScalarRelationFilter = {
    is?: DriverEvaluationWhereInput | null
    isNot?: DriverEvaluationWhereInput | null
  }

  export type TripMetricListRelationFilter = {
    every?: TripMetricWhereInput
    some?: TripMetricWhereInput
    none?: TripMetricWhereInput
  }

  export type TripMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripOrderByRelevanceInput = {
    fields: TripOrderByRelevanceFieldEnum | TripOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    distance?: SortOrder
    fuelConsumed?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripAvgOrderByAggregateInput = {
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    distance?: SortOrder
    fuelConsumed?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    distance?: SortOrder
    fuelConsumed?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    startLocation?: SortOrder
    endLocation?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    distance?: SortOrder
    fuelConsumed?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripSumOrderByAggregateInput = {
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    distance?: SortOrder
    fuelConsumed?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TripScalarRelationFilter = {
    is?: TripWhereInput
    isNot?: TripWhereInput
  }

  export type TripMetricOrderByRelevanceInput = {
    fields: TripMetricOrderByRelevanceFieldEnum | TripMetricOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TripMetricCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    speed?: SortOrder
    acceleration?: SortOrder
    braking?: SortOrder
    fuelConsumption?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
  }

  export type TripMetricAvgOrderByAggregateInput = {
    speed?: SortOrder
    acceleration?: SortOrder
    braking?: SortOrder
    fuelConsumption?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type TripMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    speed?: SortOrder
    acceleration?: SortOrder
    braking?: SortOrder
    fuelConsumption?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
  }

  export type TripMetricMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    speed?: SortOrder
    acceleration?: SortOrder
    braking?: SortOrder
    fuelConsumption?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
  }

  export type TripMetricSumOrderByAggregateInput = {
    speed?: SortOrder
    acceleration?: SortOrder
    braking?: SortOrder
    fuelConsumption?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DriverEvaluationOrderByRelevanceInput = {
    fields: DriverEvaluationOrderByRelevanceFieldEnum | DriverEvaluationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DriverEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    tripId?: SortOrder
    safetyScore?: SortOrder
    fuelEfficiencyScore?: SortOrder
    speedingInstances?: SortOrder
    hardBrakingCount?: SortOrder
    hardAccelerationCount?: SortOrder
    distractionScore?: SortOrder
    overallScore?: SortOrder
    recommendations?: SortOrder
    createdAt?: SortOrder
  }

  export type DriverEvaluationAvgOrderByAggregateInput = {
    safetyScore?: SortOrder
    fuelEfficiencyScore?: SortOrder
    speedingInstances?: SortOrder
    hardBrakingCount?: SortOrder
    hardAccelerationCount?: SortOrder
    distractionScore?: SortOrder
    overallScore?: SortOrder
  }

  export type DriverEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    tripId?: SortOrder
    safetyScore?: SortOrder
    fuelEfficiencyScore?: SortOrder
    speedingInstances?: SortOrder
    hardBrakingCount?: SortOrder
    hardAccelerationCount?: SortOrder
    distractionScore?: SortOrder
    overallScore?: SortOrder
    recommendations?: SortOrder
    createdAt?: SortOrder
  }

  export type DriverEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    tripId?: SortOrder
    safetyScore?: SortOrder
    fuelEfficiencyScore?: SortOrder
    speedingInstances?: SortOrder
    hardBrakingCount?: SortOrder
    hardAccelerationCount?: SortOrder
    distractionScore?: SortOrder
    overallScore?: SortOrder
    recommendations?: SortOrder
    createdAt?: SortOrder
  }

  export type DriverEvaluationSumOrderByAggregateInput = {
    safetyScore?: SortOrder
    fuelEfficiencyScore?: SortOrder
    speedingInstances?: SortOrder
    hardBrakingCount?: SortOrder
    hardAccelerationCount?: SortOrder
    distractionScore?: SortOrder
    overallScore?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ComponentNullableScalarRelationFilter = {
    is?: ComponentWhereInput | null
    isNot?: ComponentWhereInput | null
  }

  export type AlertOrderByRelevanceInput = {
    fields: AlertOrderByRelevanceFieldEnum | AlertOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    message?: SortOrder
    actionRequired?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    message?: SortOrder
    actionRequired?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    message?: SortOrder
    actionRequired?: SortOrder
    createdAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MaintenanceOrderByRelevanceInput = {
    fields: MaintenanceOrderByRelevanceFieldEnum | MaintenanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    maintenanceType?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    maintenanceType?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    maintenanceType?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripNullableScalarRelationFilter = {
    is?: TripWhereInput | null
    isNot?: TripWhereInput | null
  }

  export type VehicleNullableScalarRelationFilter = {
    is?: VehicleWhereInput | null
    isNot?: VehicleWhereInput | null
  }

  export type AIRecommendationOrderByRelevanceInput = {
    fields: AIRecommendationOrderByRelevanceFieldEnum | AIRecommendationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AIRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    recommendationType?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    suggestedAction?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    tripId?: SortOrder
  }

  export type AIRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    recommendationType?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    suggestedAction?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    tripId?: SortOrder
  }

  export type AIRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    recommendationType?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    suggestedAction?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    componentId?: SortOrder
    tripId?: SortOrder
  }

  export type DriverCreateNestedOneWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    connect?: DriverWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type DriverUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    connect?: DriverWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DriverUpdateOneWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    upsert?: DriverUpsertWithoutUserInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutUserInput, DriverUpdateWithoutUserInput>, DriverUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type DriverUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    upsert?: DriverUpsertWithoutUserInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutUserInput, DriverUpdateWithoutUserInput>, DriverUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type AIRecommendationCreateNestedManyWithoutDriverInput = {
    create?: XOR<AIRecommendationCreateWithoutDriverInput, AIRecommendationUncheckedCreateWithoutDriverInput> | AIRecommendationCreateWithoutDriverInput[] | AIRecommendationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutDriverInput | AIRecommendationCreateOrConnectWithoutDriverInput[]
    createMany?: AIRecommendationCreateManyDriverInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type DriverEvaluationCreateNestedManyWithoutDriverInput = {
    create?: XOR<DriverEvaluationCreateWithoutDriverInput, DriverEvaluationUncheckedCreateWithoutDriverInput> | DriverEvaluationCreateWithoutDriverInput[] | DriverEvaluationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverEvaluationCreateOrConnectWithoutDriverInput | DriverEvaluationCreateOrConnectWithoutDriverInput[]
    createMany?: DriverEvaluationCreateManyDriverInputEnvelope
    connect?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
  }

  export type DriverVehicleAssignmentCreateNestedManyWithoutDriverInput = {
    create?: XOR<DriverVehicleAssignmentCreateWithoutDriverInput, DriverVehicleAssignmentUncheckedCreateWithoutDriverInput> | DriverVehicleAssignmentCreateWithoutDriverInput[] | DriverVehicleAssignmentUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverVehicleAssignmentCreateOrConnectWithoutDriverInput | DriverVehicleAssignmentCreateOrConnectWithoutDriverInput[]
    createMany?: DriverVehicleAssignmentCreateManyDriverInputEnvelope
    connect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDriverInput = {
    create?: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverInput
    connect?: UserWhereUniqueInput
  }

  export type TripCreateNestedManyWithoutDriverInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type AIRecommendationUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<AIRecommendationCreateWithoutDriverInput, AIRecommendationUncheckedCreateWithoutDriverInput> | AIRecommendationCreateWithoutDriverInput[] | AIRecommendationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutDriverInput | AIRecommendationCreateOrConnectWithoutDriverInput[]
    createMany?: AIRecommendationCreateManyDriverInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type DriverEvaluationUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<DriverEvaluationCreateWithoutDriverInput, DriverEvaluationUncheckedCreateWithoutDriverInput> | DriverEvaluationCreateWithoutDriverInput[] | DriverEvaluationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverEvaluationCreateOrConnectWithoutDriverInput | DriverEvaluationCreateOrConnectWithoutDriverInput[]
    createMany?: DriverEvaluationCreateManyDriverInputEnvelope
    connect?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
  }

  export type DriverVehicleAssignmentUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<DriverVehicleAssignmentCreateWithoutDriverInput, DriverVehicleAssignmentUncheckedCreateWithoutDriverInput> | DriverVehicleAssignmentCreateWithoutDriverInput[] | DriverVehicleAssignmentUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverVehicleAssignmentCreateOrConnectWithoutDriverInput | DriverVehicleAssignmentCreateOrConnectWithoutDriverInput[]
    createMany?: DriverVehicleAssignmentCreateManyDriverInputEnvelope
    connect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AIRecommendationUpdateManyWithoutDriverNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutDriverInput, AIRecommendationUncheckedCreateWithoutDriverInput> | AIRecommendationCreateWithoutDriverInput[] | AIRecommendationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutDriverInput | AIRecommendationCreateOrConnectWithoutDriverInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutDriverInput | AIRecommendationUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: AIRecommendationCreateManyDriverInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutDriverInput | AIRecommendationUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutDriverInput | AIRecommendationUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type DriverEvaluationUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DriverEvaluationCreateWithoutDriverInput, DriverEvaluationUncheckedCreateWithoutDriverInput> | DriverEvaluationCreateWithoutDriverInput[] | DriverEvaluationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverEvaluationCreateOrConnectWithoutDriverInput | DriverEvaluationCreateOrConnectWithoutDriverInput[]
    upsert?: DriverEvaluationUpsertWithWhereUniqueWithoutDriverInput | DriverEvaluationUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DriverEvaluationCreateManyDriverInputEnvelope
    set?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
    disconnect?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
    delete?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
    connect?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
    update?: DriverEvaluationUpdateWithWhereUniqueWithoutDriverInput | DriverEvaluationUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DriverEvaluationUpdateManyWithWhereWithoutDriverInput | DriverEvaluationUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DriverEvaluationScalarWhereInput | DriverEvaluationScalarWhereInput[]
  }

  export type DriverVehicleAssignmentUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DriverVehicleAssignmentCreateWithoutDriverInput, DriverVehicleAssignmentUncheckedCreateWithoutDriverInput> | DriverVehicleAssignmentCreateWithoutDriverInput[] | DriverVehicleAssignmentUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverVehicleAssignmentCreateOrConnectWithoutDriverInput | DriverVehicleAssignmentCreateOrConnectWithoutDriverInput[]
    upsert?: DriverVehicleAssignmentUpsertWithWhereUniqueWithoutDriverInput | DriverVehicleAssignmentUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DriverVehicleAssignmentCreateManyDriverInputEnvelope
    set?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    disconnect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    delete?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    connect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    update?: DriverVehicleAssignmentUpdateWithWhereUniqueWithoutDriverInput | DriverVehicleAssignmentUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DriverVehicleAssignmentUpdateManyWithWhereWithoutDriverInput | DriverVehicleAssignmentUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DriverVehicleAssignmentScalarWhereInput | DriverVehicleAssignmentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutDriverNestedInput = {
    create?: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverInput
    upsert?: UserUpsertWithoutDriverInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDriverInput, UserUpdateWithoutDriverInput>, UserUncheckedUpdateWithoutDriverInput>
  }

  export type TripUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutDriverInput | TripUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutDriverInput | TripUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TripUpdateManyWithWhereWithoutDriverInput | TripUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type AIRecommendationUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutDriverInput, AIRecommendationUncheckedCreateWithoutDriverInput> | AIRecommendationCreateWithoutDriverInput[] | AIRecommendationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutDriverInput | AIRecommendationCreateOrConnectWithoutDriverInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutDriverInput | AIRecommendationUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: AIRecommendationCreateManyDriverInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutDriverInput | AIRecommendationUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutDriverInput | AIRecommendationUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type DriverEvaluationUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DriverEvaluationCreateWithoutDriverInput, DriverEvaluationUncheckedCreateWithoutDriverInput> | DriverEvaluationCreateWithoutDriverInput[] | DriverEvaluationUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverEvaluationCreateOrConnectWithoutDriverInput | DriverEvaluationCreateOrConnectWithoutDriverInput[]
    upsert?: DriverEvaluationUpsertWithWhereUniqueWithoutDriverInput | DriverEvaluationUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DriverEvaluationCreateManyDriverInputEnvelope
    set?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
    disconnect?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
    delete?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
    connect?: DriverEvaluationWhereUniqueInput | DriverEvaluationWhereUniqueInput[]
    update?: DriverEvaluationUpdateWithWhereUniqueWithoutDriverInput | DriverEvaluationUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DriverEvaluationUpdateManyWithWhereWithoutDriverInput | DriverEvaluationUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DriverEvaluationScalarWhereInput | DriverEvaluationScalarWhereInput[]
  }

  export type DriverVehicleAssignmentUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DriverVehicleAssignmentCreateWithoutDriverInput, DriverVehicleAssignmentUncheckedCreateWithoutDriverInput> | DriverVehicleAssignmentCreateWithoutDriverInput[] | DriverVehicleAssignmentUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DriverVehicleAssignmentCreateOrConnectWithoutDriverInput | DriverVehicleAssignmentCreateOrConnectWithoutDriverInput[]
    upsert?: DriverVehicleAssignmentUpsertWithWhereUniqueWithoutDriverInput | DriverVehicleAssignmentUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DriverVehicleAssignmentCreateManyDriverInputEnvelope
    set?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    disconnect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    delete?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    connect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    update?: DriverVehicleAssignmentUpdateWithWhereUniqueWithoutDriverInput | DriverVehicleAssignmentUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DriverVehicleAssignmentUpdateManyWithWhereWithoutDriverInput | DriverVehicleAssignmentUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DriverVehicleAssignmentScalarWhereInput | DriverVehicleAssignmentScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutDriverInput | TripUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutDriverInput | TripUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TripUpdateManyWithWhereWithoutDriverInput | TripUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type AIRecommendationCreateNestedManyWithoutVehicleInput = {
    create?: XOR<AIRecommendationCreateWithoutVehicleInput, AIRecommendationUncheckedCreateWithoutVehicleInput> | AIRecommendationCreateWithoutVehicleInput[] | AIRecommendationUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutVehicleInput | AIRecommendationCreateOrConnectWithoutVehicleInput[]
    createMany?: AIRecommendationCreateManyVehicleInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutVehicleInput = {
    create?: XOR<AlertCreateWithoutVehicleInput, AlertUncheckedCreateWithoutVehicleInput> | AlertCreateWithoutVehicleInput[] | AlertUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutVehicleInput | AlertCreateOrConnectWithoutVehicleInput[]
    createMany?: AlertCreateManyVehicleInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type ComponentCreateNestedManyWithoutVehicleInput = {
    create?: XOR<ComponentCreateWithoutVehicleInput, ComponentUncheckedCreateWithoutVehicleInput> | ComponentCreateWithoutVehicleInput[] | ComponentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutVehicleInput | ComponentCreateOrConnectWithoutVehicleInput[]
    createMany?: ComponentCreateManyVehicleInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type DriverVehicleAssignmentCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DriverVehicleAssignmentCreateWithoutVehicleInput, DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput> | DriverVehicleAssignmentCreateWithoutVehicleInput[] | DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput | DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput[]
    createMany?: DriverVehicleAssignmentCreateManyVehicleInputEnvelope
    connect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
  }

  export type MaintenanceCreateNestedManyWithoutVehicleInput = {
    create?: XOR<MaintenanceCreateWithoutVehicleInput, MaintenanceUncheckedCreateWithoutVehicleInput> | MaintenanceCreateWithoutVehicleInput[] | MaintenanceUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutVehicleInput | MaintenanceCreateOrConnectWithoutVehicleInput[]
    createMany?: MaintenanceCreateManyVehicleInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type TripCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput> | TripCreateWithoutVehicleInput[] | TripUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripCreateOrConnectWithoutVehicleInput | TripCreateOrConnectWithoutVehicleInput[]
    createMany?: TripCreateManyVehicleInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type AIRecommendationUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<AIRecommendationCreateWithoutVehicleInput, AIRecommendationUncheckedCreateWithoutVehicleInput> | AIRecommendationCreateWithoutVehicleInput[] | AIRecommendationUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutVehicleInput | AIRecommendationCreateOrConnectWithoutVehicleInput[]
    createMany?: AIRecommendationCreateManyVehicleInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<AlertCreateWithoutVehicleInput, AlertUncheckedCreateWithoutVehicleInput> | AlertCreateWithoutVehicleInput[] | AlertUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutVehicleInput | AlertCreateOrConnectWithoutVehicleInput[]
    createMany?: AlertCreateManyVehicleInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type ComponentUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<ComponentCreateWithoutVehicleInput, ComponentUncheckedCreateWithoutVehicleInput> | ComponentCreateWithoutVehicleInput[] | ComponentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutVehicleInput | ComponentCreateOrConnectWithoutVehicleInput[]
    createMany?: ComponentCreateManyVehicleInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type DriverVehicleAssignmentUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DriverVehicleAssignmentCreateWithoutVehicleInput, DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput> | DriverVehicleAssignmentCreateWithoutVehicleInput[] | DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput | DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput[]
    createMany?: DriverVehicleAssignmentCreateManyVehicleInputEnvelope
    connect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<MaintenanceCreateWithoutVehicleInput, MaintenanceUncheckedCreateWithoutVehicleInput> | MaintenanceCreateWithoutVehicleInput[] | MaintenanceUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutVehicleInput | MaintenanceCreateOrConnectWithoutVehicleInput[]
    createMany?: MaintenanceCreateManyVehicleInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput> | TripCreateWithoutVehicleInput[] | TripUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripCreateOrConnectWithoutVehicleInput | TripCreateOrConnectWithoutVehicleInput[]
    createMany?: TripCreateManyVehicleInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AIRecommendationUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutVehicleInput, AIRecommendationUncheckedCreateWithoutVehicleInput> | AIRecommendationCreateWithoutVehicleInput[] | AIRecommendationUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutVehicleInput | AIRecommendationCreateOrConnectWithoutVehicleInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutVehicleInput | AIRecommendationUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: AIRecommendationCreateManyVehicleInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutVehicleInput | AIRecommendationUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutVehicleInput | AIRecommendationUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<AlertCreateWithoutVehicleInput, AlertUncheckedCreateWithoutVehicleInput> | AlertCreateWithoutVehicleInput[] | AlertUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutVehicleInput | AlertCreateOrConnectWithoutVehicleInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutVehicleInput | AlertUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: AlertCreateManyVehicleInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutVehicleInput | AlertUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutVehicleInput | AlertUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type ComponentUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<ComponentCreateWithoutVehicleInput, ComponentUncheckedCreateWithoutVehicleInput> | ComponentCreateWithoutVehicleInput[] | ComponentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutVehicleInput | ComponentCreateOrConnectWithoutVehicleInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutVehicleInput | ComponentUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: ComponentCreateManyVehicleInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutVehicleInput | ComponentUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutVehicleInput | ComponentUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type DriverVehicleAssignmentUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DriverVehicleAssignmentCreateWithoutVehicleInput, DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput> | DriverVehicleAssignmentCreateWithoutVehicleInput[] | DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput | DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput[]
    upsert?: DriverVehicleAssignmentUpsertWithWhereUniqueWithoutVehicleInput | DriverVehicleAssignmentUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DriverVehicleAssignmentCreateManyVehicleInputEnvelope
    set?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    disconnect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    delete?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    connect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    update?: DriverVehicleAssignmentUpdateWithWhereUniqueWithoutVehicleInput | DriverVehicleAssignmentUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DriverVehicleAssignmentUpdateManyWithWhereWithoutVehicleInput | DriverVehicleAssignmentUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DriverVehicleAssignmentScalarWhereInput | DriverVehicleAssignmentScalarWhereInput[]
  }

  export type MaintenanceUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<MaintenanceCreateWithoutVehicleInput, MaintenanceUncheckedCreateWithoutVehicleInput> | MaintenanceCreateWithoutVehicleInput[] | MaintenanceUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutVehicleInput | MaintenanceCreateOrConnectWithoutVehicleInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutVehicleInput | MaintenanceUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: MaintenanceCreateManyVehicleInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutVehicleInput | MaintenanceUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutVehicleInput | MaintenanceUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type TripUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput> | TripCreateWithoutVehicleInput[] | TripUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripCreateOrConnectWithoutVehicleInput | TripCreateOrConnectWithoutVehicleInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutVehicleInput | TripUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TripCreateManyVehicleInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutVehicleInput | TripUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TripUpdateManyWithWhereWithoutVehicleInput | TripUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type AIRecommendationUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutVehicleInput, AIRecommendationUncheckedCreateWithoutVehicleInput> | AIRecommendationCreateWithoutVehicleInput[] | AIRecommendationUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutVehicleInput | AIRecommendationCreateOrConnectWithoutVehicleInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutVehicleInput | AIRecommendationUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: AIRecommendationCreateManyVehicleInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutVehicleInput | AIRecommendationUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutVehicleInput | AIRecommendationUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<AlertCreateWithoutVehicleInput, AlertUncheckedCreateWithoutVehicleInput> | AlertCreateWithoutVehicleInput[] | AlertUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutVehicleInput | AlertCreateOrConnectWithoutVehicleInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutVehicleInput | AlertUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: AlertCreateManyVehicleInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutVehicleInput | AlertUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutVehicleInput | AlertUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type ComponentUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<ComponentCreateWithoutVehicleInput, ComponentUncheckedCreateWithoutVehicleInput> | ComponentCreateWithoutVehicleInput[] | ComponentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutVehicleInput | ComponentCreateOrConnectWithoutVehicleInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutVehicleInput | ComponentUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: ComponentCreateManyVehicleInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutVehicleInput | ComponentUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutVehicleInput | ComponentUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DriverVehicleAssignmentCreateWithoutVehicleInput, DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput> | DriverVehicleAssignmentCreateWithoutVehicleInput[] | DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput | DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput[]
    upsert?: DriverVehicleAssignmentUpsertWithWhereUniqueWithoutVehicleInput | DriverVehicleAssignmentUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DriverVehicleAssignmentCreateManyVehicleInputEnvelope
    set?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    disconnect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    delete?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    connect?: DriverVehicleAssignmentWhereUniqueInput | DriverVehicleAssignmentWhereUniqueInput[]
    update?: DriverVehicleAssignmentUpdateWithWhereUniqueWithoutVehicleInput | DriverVehicleAssignmentUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DriverVehicleAssignmentUpdateManyWithWhereWithoutVehicleInput | DriverVehicleAssignmentUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DriverVehicleAssignmentScalarWhereInput | DriverVehicleAssignmentScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<MaintenanceCreateWithoutVehicleInput, MaintenanceUncheckedCreateWithoutVehicleInput> | MaintenanceCreateWithoutVehicleInput[] | MaintenanceUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutVehicleInput | MaintenanceCreateOrConnectWithoutVehicleInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutVehicleInput | MaintenanceUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: MaintenanceCreateManyVehicleInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutVehicleInput | MaintenanceUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutVehicleInput | MaintenanceUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput> | TripCreateWithoutVehicleInput[] | TripUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripCreateOrConnectWithoutVehicleInput | TripCreateOrConnectWithoutVehicleInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutVehicleInput | TripUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TripCreateManyVehicleInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutVehicleInput | TripUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TripUpdateManyWithWhereWithoutVehicleInput | TripUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type DriverCreateNestedOneWithoutAssignedVehiclesInput = {
    create?: XOR<DriverCreateWithoutAssignedVehiclesInput, DriverUncheckedCreateWithoutAssignedVehiclesInput>
    connectOrCreate?: DriverCreateOrConnectWithoutAssignedVehiclesInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutAssignedDriversInput = {
    create?: XOR<VehicleCreateWithoutAssignedDriversInput, VehicleUncheckedCreateWithoutAssignedDriversInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutAssignedDriversInput
    connect?: VehicleWhereUniqueInput
  }

  export type DriverUpdateOneRequiredWithoutAssignedVehiclesNestedInput = {
    create?: XOR<DriverCreateWithoutAssignedVehiclesInput, DriverUncheckedCreateWithoutAssignedVehiclesInput>
    connectOrCreate?: DriverCreateOrConnectWithoutAssignedVehiclesInput
    upsert?: DriverUpsertWithoutAssignedVehiclesInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutAssignedVehiclesInput, DriverUpdateWithoutAssignedVehiclesInput>, DriverUncheckedUpdateWithoutAssignedVehiclesInput>
  }

  export type VehicleUpdateOneRequiredWithoutAssignedDriversNestedInput = {
    create?: XOR<VehicleCreateWithoutAssignedDriversInput, VehicleUncheckedCreateWithoutAssignedDriversInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutAssignedDriversInput
    upsert?: VehicleUpsertWithoutAssignedDriversInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutAssignedDriversInput, VehicleUpdateWithoutAssignedDriversInput>, VehicleUncheckedUpdateWithoutAssignedDriversInput>
  }

  export type AIRecommendationCreateNestedManyWithoutComponentInput = {
    create?: XOR<AIRecommendationCreateWithoutComponentInput, AIRecommendationUncheckedCreateWithoutComponentInput> | AIRecommendationCreateWithoutComponentInput[] | AIRecommendationUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutComponentInput | AIRecommendationCreateOrConnectWithoutComponentInput[]
    createMany?: AIRecommendationCreateManyComponentInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutComponentInput = {
    create?: XOR<AlertCreateWithoutComponentInput, AlertUncheckedCreateWithoutComponentInput> | AlertCreateWithoutComponentInput[] | AlertUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutComponentInput | AlertCreateOrConnectWithoutComponentInput[]
    createMany?: AlertCreateManyComponentInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type VehicleCreateNestedOneWithoutComponentsInput = {
    create?: XOR<VehicleCreateWithoutComponentsInput, VehicleUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutComponentsInput
    connect?: VehicleWhereUniqueInput
  }

  export type MaintenanceCreateNestedManyWithoutComponentInput = {
    create?: XOR<MaintenanceCreateWithoutComponentInput, MaintenanceUncheckedCreateWithoutComponentInput> | MaintenanceCreateWithoutComponentInput[] | MaintenanceUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutComponentInput | MaintenanceCreateOrConnectWithoutComponentInput[]
    createMany?: MaintenanceCreateManyComponentInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type AIRecommendationUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<AIRecommendationCreateWithoutComponentInput, AIRecommendationUncheckedCreateWithoutComponentInput> | AIRecommendationCreateWithoutComponentInput[] | AIRecommendationUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutComponentInput | AIRecommendationCreateOrConnectWithoutComponentInput[]
    createMany?: AIRecommendationCreateManyComponentInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<AlertCreateWithoutComponentInput, AlertUncheckedCreateWithoutComponentInput> | AlertCreateWithoutComponentInput[] | AlertUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutComponentInput | AlertCreateOrConnectWithoutComponentInput[]
    createMany?: AlertCreateManyComponentInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<MaintenanceCreateWithoutComponentInput, MaintenanceUncheckedCreateWithoutComponentInput> | MaintenanceCreateWithoutComponentInput[] | MaintenanceUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutComponentInput | MaintenanceCreateOrConnectWithoutComponentInput[]
    createMany?: MaintenanceCreateManyComponentInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AIRecommendationUpdateManyWithoutComponentNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutComponentInput, AIRecommendationUncheckedCreateWithoutComponentInput> | AIRecommendationCreateWithoutComponentInput[] | AIRecommendationUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutComponentInput | AIRecommendationCreateOrConnectWithoutComponentInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutComponentInput | AIRecommendationUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: AIRecommendationCreateManyComponentInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutComponentInput | AIRecommendationUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutComponentInput | AIRecommendationUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutComponentNestedInput = {
    create?: XOR<AlertCreateWithoutComponentInput, AlertUncheckedCreateWithoutComponentInput> | AlertCreateWithoutComponentInput[] | AlertUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutComponentInput | AlertCreateOrConnectWithoutComponentInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutComponentInput | AlertUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: AlertCreateManyComponentInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutComponentInput | AlertUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutComponentInput | AlertUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type VehicleUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<VehicleCreateWithoutComponentsInput, VehicleUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutComponentsInput
    upsert?: VehicleUpsertWithoutComponentsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutComponentsInput, VehicleUpdateWithoutComponentsInput>, VehicleUncheckedUpdateWithoutComponentsInput>
  }

  export type MaintenanceUpdateManyWithoutComponentNestedInput = {
    create?: XOR<MaintenanceCreateWithoutComponentInput, MaintenanceUncheckedCreateWithoutComponentInput> | MaintenanceCreateWithoutComponentInput[] | MaintenanceUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutComponentInput | MaintenanceCreateOrConnectWithoutComponentInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutComponentInput | MaintenanceUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: MaintenanceCreateManyComponentInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutComponentInput | MaintenanceUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutComponentInput | MaintenanceUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type AIRecommendationUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutComponentInput, AIRecommendationUncheckedCreateWithoutComponentInput> | AIRecommendationCreateWithoutComponentInput[] | AIRecommendationUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutComponentInput | AIRecommendationCreateOrConnectWithoutComponentInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutComponentInput | AIRecommendationUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: AIRecommendationCreateManyComponentInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutComponentInput | AIRecommendationUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutComponentInput | AIRecommendationUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<AlertCreateWithoutComponentInput, AlertUncheckedCreateWithoutComponentInput> | AlertCreateWithoutComponentInput[] | AlertUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutComponentInput | AlertCreateOrConnectWithoutComponentInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutComponentInput | AlertUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: AlertCreateManyComponentInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutComponentInput | AlertUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutComponentInput | AlertUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<MaintenanceCreateWithoutComponentInput, MaintenanceUncheckedCreateWithoutComponentInput> | MaintenanceCreateWithoutComponentInput[] | MaintenanceUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutComponentInput | MaintenanceCreateOrConnectWithoutComponentInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutComponentInput | MaintenanceUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: MaintenanceCreateManyComponentInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutComponentInput | MaintenanceUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutComponentInput | MaintenanceUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type AIRecommendationCreateNestedManyWithoutTripInput = {
    create?: XOR<AIRecommendationCreateWithoutTripInput, AIRecommendationUncheckedCreateWithoutTripInput> | AIRecommendationCreateWithoutTripInput[] | AIRecommendationUncheckedCreateWithoutTripInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutTripInput | AIRecommendationCreateOrConnectWithoutTripInput[]
    createMany?: AIRecommendationCreateManyTripInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type DriverEvaluationCreateNestedOneWithoutTripInput = {
    create?: XOR<DriverEvaluationCreateWithoutTripInput, DriverEvaluationUncheckedCreateWithoutTripInput>
    connectOrCreate?: DriverEvaluationCreateOrConnectWithoutTripInput
    connect?: DriverEvaluationWhereUniqueInput
  }

  export type TripMetricCreateNestedManyWithoutTripInput = {
    create?: XOR<TripMetricCreateWithoutTripInput, TripMetricUncheckedCreateWithoutTripInput> | TripMetricCreateWithoutTripInput[] | TripMetricUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMetricCreateOrConnectWithoutTripInput | TripMetricCreateOrConnectWithoutTripInput[]
    createMany?: TripMetricCreateManyTripInputEnvelope
    connect?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
  }

  export type DriverCreateNestedOneWithoutTripsInput = {
    create?: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTripsInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutTripsInput = {
    create?: XOR<VehicleCreateWithoutTripsInput, VehicleUncheckedCreateWithoutTripsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTripsInput
    connect?: VehicleWhereUniqueInput
  }

  export type AIRecommendationUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<AIRecommendationCreateWithoutTripInput, AIRecommendationUncheckedCreateWithoutTripInput> | AIRecommendationCreateWithoutTripInput[] | AIRecommendationUncheckedCreateWithoutTripInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutTripInput | AIRecommendationCreateOrConnectWithoutTripInput[]
    createMany?: AIRecommendationCreateManyTripInputEnvelope
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
  }

  export type DriverEvaluationUncheckedCreateNestedOneWithoutTripInput = {
    create?: XOR<DriverEvaluationCreateWithoutTripInput, DriverEvaluationUncheckedCreateWithoutTripInput>
    connectOrCreate?: DriverEvaluationCreateOrConnectWithoutTripInput
    connect?: DriverEvaluationWhereUniqueInput
  }

  export type TripMetricUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<TripMetricCreateWithoutTripInput, TripMetricUncheckedCreateWithoutTripInput> | TripMetricCreateWithoutTripInput[] | TripMetricUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMetricCreateOrConnectWithoutTripInput | TripMetricCreateOrConnectWithoutTripInput[]
    createMany?: TripMetricCreateManyTripInputEnvelope
    connect?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AIRecommendationUpdateManyWithoutTripNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutTripInput, AIRecommendationUncheckedCreateWithoutTripInput> | AIRecommendationCreateWithoutTripInput[] | AIRecommendationUncheckedCreateWithoutTripInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutTripInput | AIRecommendationCreateOrConnectWithoutTripInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutTripInput | AIRecommendationUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: AIRecommendationCreateManyTripInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutTripInput | AIRecommendationUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutTripInput | AIRecommendationUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type DriverEvaluationUpdateOneWithoutTripNestedInput = {
    create?: XOR<DriverEvaluationCreateWithoutTripInput, DriverEvaluationUncheckedCreateWithoutTripInput>
    connectOrCreate?: DriverEvaluationCreateOrConnectWithoutTripInput
    upsert?: DriverEvaluationUpsertWithoutTripInput
    disconnect?: DriverEvaluationWhereInput | boolean
    delete?: DriverEvaluationWhereInput | boolean
    connect?: DriverEvaluationWhereUniqueInput
    update?: XOR<XOR<DriverEvaluationUpdateToOneWithWhereWithoutTripInput, DriverEvaluationUpdateWithoutTripInput>, DriverEvaluationUncheckedUpdateWithoutTripInput>
  }

  export type TripMetricUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripMetricCreateWithoutTripInput, TripMetricUncheckedCreateWithoutTripInput> | TripMetricCreateWithoutTripInput[] | TripMetricUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMetricCreateOrConnectWithoutTripInput | TripMetricCreateOrConnectWithoutTripInput[]
    upsert?: TripMetricUpsertWithWhereUniqueWithoutTripInput | TripMetricUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripMetricCreateManyTripInputEnvelope
    set?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
    disconnect?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
    delete?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
    connect?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
    update?: TripMetricUpdateWithWhereUniqueWithoutTripInput | TripMetricUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripMetricUpdateManyWithWhereWithoutTripInput | TripMetricUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripMetricScalarWhereInput | TripMetricScalarWhereInput[]
  }

  export type DriverUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTripsInput
    upsert?: DriverUpsertWithoutTripsInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutTripsInput, DriverUpdateWithoutTripsInput>, DriverUncheckedUpdateWithoutTripsInput>
  }

  export type VehicleUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<VehicleCreateWithoutTripsInput, VehicleUncheckedCreateWithoutTripsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTripsInput
    upsert?: VehicleUpsertWithoutTripsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutTripsInput, VehicleUpdateWithoutTripsInput>, VehicleUncheckedUpdateWithoutTripsInput>
  }

  export type AIRecommendationUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<AIRecommendationCreateWithoutTripInput, AIRecommendationUncheckedCreateWithoutTripInput> | AIRecommendationCreateWithoutTripInput[] | AIRecommendationUncheckedCreateWithoutTripInput[]
    connectOrCreate?: AIRecommendationCreateOrConnectWithoutTripInput | AIRecommendationCreateOrConnectWithoutTripInput[]
    upsert?: AIRecommendationUpsertWithWhereUniqueWithoutTripInput | AIRecommendationUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: AIRecommendationCreateManyTripInputEnvelope
    set?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    disconnect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    delete?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    connect?: AIRecommendationWhereUniqueInput | AIRecommendationWhereUniqueInput[]
    update?: AIRecommendationUpdateWithWhereUniqueWithoutTripInput | AIRecommendationUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: AIRecommendationUpdateManyWithWhereWithoutTripInput | AIRecommendationUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
  }

  export type DriverEvaluationUncheckedUpdateOneWithoutTripNestedInput = {
    create?: XOR<DriverEvaluationCreateWithoutTripInput, DriverEvaluationUncheckedCreateWithoutTripInput>
    connectOrCreate?: DriverEvaluationCreateOrConnectWithoutTripInput
    upsert?: DriverEvaluationUpsertWithoutTripInput
    disconnect?: DriverEvaluationWhereInput | boolean
    delete?: DriverEvaluationWhereInput | boolean
    connect?: DriverEvaluationWhereUniqueInput
    update?: XOR<XOR<DriverEvaluationUpdateToOneWithWhereWithoutTripInput, DriverEvaluationUpdateWithoutTripInput>, DriverEvaluationUncheckedUpdateWithoutTripInput>
  }

  export type TripMetricUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<TripMetricCreateWithoutTripInput, TripMetricUncheckedCreateWithoutTripInput> | TripMetricCreateWithoutTripInput[] | TripMetricUncheckedCreateWithoutTripInput[]
    connectOrCreate?: TripMetricCreateOrConnectWithoutTripInput | TripMetricCreateOrConnectWithoutTripInput[]
    upsert?: TripMetricUpsertWithWhereUniqueWithoutTripInput | TripMetricUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: TripMetricCreateManyTripInputEnvelope
    set?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
    disconnect?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
    delete?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
    connect?: TripMetricWhereUniqueInput | TripMetricWhereUniqueInput[]
    update?: TripMetricUpdateWithWhereUniqueWithoutTripInput | TripMetricUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: TripMetricUpdateManyWithWhereWithoutTripInput | TripMetricUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: TripMetricScalarWhereInput | TripMetricScalarWhereInput[]
  }

  export type TripCreateNestedOneWithoutMetricsInput = {
    create?: XOR<TripCreateWithoutMetricsInput, TripUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: TripCreateOrConnectWithoutMetricsInput
    connect?: TripWhereUniqueInput
  }

  export type TripUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<TripCreateWithoutMetricsInput, TripUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: TripCreateOrConnectWithoutMetricsInput
    upsert?: TripUpsertWithoutMetricsInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutMetricsInput, TripUpdateWithoutMetricsInput>, TripUncheckedUpdateWithoutMetricsInput>
  }

  export type DriverCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<DriverCreateWithoutEvaluationsInput, DriverUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutEvaluationsInput
    connect?: DriverWhereUniqueInput
  }

  export type TripCreateNestedOneWithoutEvaluationInput = {
    create?: XOR<TripCreateWithoutEvaluationInput, TripUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: TripCreateOrConnectWithoutEvaluationInput
    connect?: TripWhereUniqueInput
  }

  export type DriverUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<DriverCreateWithoutEvaluationsInput, DriverUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutEvaluationsInput
    upsert?: DriverUpsertWithoutEvaluationsInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutEvaluationsInput, DriverUpdateWithoutEvaluationsInput>, DriverUncheckedUpdateWithoutEvaluationsInput>
  }

  export type TripUpdateOneRequiredWithoutEvaluationNestedInput = {
    create?: XOR<TripCreateWithoutEvaluationInput, TripUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: TripCreateOrConnectWithoutEvaluationInput
    upsert?: TripUpsertWithoutEvaluationInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutEvaluationInput, TripUpdateWithoutEvaluationInput>, TripUncheckedUpdateWithoutEvaluationInput>
  }

  export type ComponentCreateNestedOneWithoutAlertsInput = {
    create?: XOR<ComponentCreateWithoutAlertsInput, ComponentUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutAlertsInput
    connect?: ComponentWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutAlertsInput = {
    create?: XOR<VehicleCreateWithoutAlertsInput, VehicleUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutAlertsInput
    connect?: VehicleWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ComponentUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<ComponentCreateWithoutAlertsInput, ComponentUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutAlertsInput
    upsert?: ComponentUpsertWithoutAlertsInput
    disconnect?: ComponentWhereInput | boolean
    delete?: ComponentWhereInput | boolean
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutAlertsInput, ComponentUpdateWithoutAlertsInput>, ComponentUncheckedUpdateWithoutAlertsInput>
  }

  export type VehicleUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<VehicleCreateWithoutAlertsInput, VehicleUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutAlertsInput
    upsert?: VehicleUpsertWithoutAlertsInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutAlertsInput, VehicleUpdateWithoutAlertsInput>, VehicleUncheckedUpdateWithoutAlertsInput>
  }

  export type ComponentCreateNestedOneWithoutMaintenanceInput = {
    create?: XOR<ComponentCreateWithoutMaintenanceInput, ComponentUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutMaintenanceInput
    connect?: ComponentWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutMaintenanceInput = {
    create?: XOR<VehicleCreateWithoutMaintenanceInput, VehicleUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutMaintenanceInput
    connect?: VehicleWhereUniqueInput
  }

  export type ComponentUpdateOneWithoutMaintenanceNestedInput = {
    create?: XOR<ComponentCreateWithoutMaintenanceInput, ComponentUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutMaintenanceInput
    upsert?: ComponentUpsertWithoutMaintenanceInput
    disconnect?: ComponentWhereInput | boolean
    delete?: ComponentWhereInput | boolean
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutMaintenanceInput, ComponentUpdateWithoutMaintenanceInput>, ComponentUncheckedUpdateWithoutMaintenanceInput>
  }

  export type VehicleUpdateOneRequiredWithoutMaintenanceNestedInput = {
    create?: XOR<VehicleCreateWithoutMaintenanceInput, VehicleUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutMaintenanceInput
    upsert?: VehicleUpsertWithoutMaintenanceInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutMaintenanceInput, VehicleUpdateWithoutMaintenanceInput>, VehicleUncheckedUpdateWithoutMaintenanceInput>
  }

  export type ComponentCreateNestedOneWithoutAiRecommendationsInput = {
    create?: XOR<ComponentCreateWithoutAiRecommendationsInput, ComponentUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutAiRecommendationsInput
    connect?: ComponentWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutAiRecommendationsInput = {
    create?: XOR<DriverCreateWithoutAiRecommendationsInput, DriverUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutAiRecommendationsInput
    connect?: DriverWhereUniqueInput
  }

  export type TripCreateNestedOneWithoutAiRecommendationsInput = {
    create?: XOR<TripCreateWithoutAiRecommendationsInput, TripUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: TripCreateOrConnectWithoutAiRecommendationsInput
    connect?: TripWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutAiRecommendationsInput = {
    create?: XOR<VehicleCreateWithoutAiRecommendationsInput, VehicleUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutAiRecommendationsInput
    connect?: VehicleWhereUniqueInput
  }

  export type ComponentUpdateOneWithoutAiRecommendationsNestedInput = {
    create?: XOR<ComponentCreateWithoutAiRecommendationsInput, ComponentUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: ComponentCreateOrConnectWithoutAiRecommendationsInput
    upsert?: ComponentUpsertWithoutAiRecommendationsInput
    disconnect?: ComponentWhereInput | boolean
    delete?: ComponentWhereInput | boolean
    connect?: ComponentWhereUniqueInput
    update?: XOR<XOR<ComponentUpdateToOneWithWhereWithoutAiRecommendationsInput, ComponentUpdateWithoutAiRecommendationsInput>, ComponentUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type DriverUpdateOneWithoutAiRecommendationsNestedInput = {
    create?: XOR<DriverCreateWithoutAiRecommendationsInput, DriverUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutAiRecommendationsInput
    upsert?: DriverUpsertWithoutAiRecommendationsInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutAiRecommendationsInput, DriverUpdateWithoutAiRecommendationsInput>, DriverUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type TripUpdateOneWithoutAiRecommendationsNestedInput = {
    create?: XOR<TripCreateWithoutAiRecommendationsInput, TripUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: TripCreateOrConnectWithoutAiRecommendationsInput
    upsert?: TripUpsertWithoutAiRecommendationsInput
    disconnect?: TripWhereInput | boolean
    delete?: TripWhereInput | boolean
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutAiRecommendationsInput, TripUpdateWithoutAiRecommendationsInput>, TripUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type VehicleUpdateOneWithoutAiRecommendationsNestedInput = {
    create?: XOR<VehicleCreateWithoutAiRecommendationsInput, VehicleUncheckedCreateWithoutAiRecommendationsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutAiRecommendationsInput
    upsert?: VehicleUpsertWithoutAiRecommendationsInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutAiRecommendationsInput, VehicleUpdateWithoutAiRecommendationsInput>, VehicleUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DriverCreateWithoutUserInput = {
    id?: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutDriverInput
    evaluations?: DriverEvaluationCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentCreateNestedManyWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutDriverInput
    evaluations?: DriverEvaluationUncheckedCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutUserInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DriverUpsertWithoutUserInput = {
    update: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutUserInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
  }

  export type DriverUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutDriverNestedInput
    evaluations?: DriverEvaluationUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUpdateManyWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutDriverNestedInput
    evaluations?: DriverEvaluationUncheckedUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    userId?: StringFilter<"RefreshToken"> | string
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    driver?: DriverCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AIRecommendationCreateWithoutDriverInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    component?: ComponentCreateNestedOneWithoutAiRecommendationsInput
    trip?: TripCreateNestedOneWithoutAiRecommendationsInput
    vehicle?: VehicleCreateNestedOneWithoutAiRecommendationsInput
  }

  export type AIRecommendationUncheckedCreateWithoutDriverInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    vehicleId?: string | null
    componentId?: string | null
    tripId?: string | null
  }

  export type AIRecommendationCreateOrConnectWithoutDriverInput = {
    where: AIRecommendationWhereUniqueInput
    create: XOR<AIRecommendationCreateWithoutDriverInput, AIRecommendationUncheckedCreateWithoutDriverInput>
  }

  export type AIRecommendationCreateManyDriverInputEnvelope = {
    data: AIRecommendationCreateManyDriverInput | AIRecommendationCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type DriverEvaluationCreateWithoutDriverInput = {
    id?: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations?: string | null
    createdAt?: Date | string
    trip: TripCreateNestedOneWithoutEvaluationInput
  }

  export type DriverEvaluationUncheckedCreateWithoutDriverInput = {
    id?: string
    tripId: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations?: string | null
    createdAt?: Date | string
  }

  export type DriverEvaluationCreateOrConnectWithoutDriverInput = {
    where: DriverEvaluationWhereUniqueInput
    create: XOR<DriverEvaluationCreateWithoutDriverInput, DriverEvaluationUncheckedCreateWithoutDriverInput>
  }

  export type DriverEvaluationCreateManyDriverInputEnvelope = {
    data: DriverEvaluationCreateManyDriverInput | DriverEvaluationCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type DriverVehicleAssignmentCreateWithoutDriverInput = {
    assignedAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutAssignedDriversInput
  }

  export type DriverVehicleAssignmentUncheckedCreateWithoutDriverInput = {
    vehicleId: string
    assignedAt?: Date | string
  }

  export type DriverVehicleAssignmentCreateOrConnectWithoutDriverInput = {
    where: DriverVehicleAssignmentWhereUniqueInput
    create: XOR<DriverVehicleAssignmentCreateWithoutDriverInput, DriverVehicleAssignmentUncheckedCreateWithoutDriverInput>
  }

  export type DriverVehicleAssignmentCreateManyDriverInputEnvelope = {
    data: DriverVehicleAssignmentCreateManyDriverInput | DriverVehicleAssignmentCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDriverInput = {
    id?: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDriverInput = {
    id?: string
    email: string
    password: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDriverInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
  }

  export type TripCreateWithoutDriverInput = {
    id?: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutTripInput
    evaluation?: DriverEvaluationCreateNestedOneWithoutTripInput
    metrics?: TripMetricCreateNestedManyWithoutTripInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutDriverInput = {
    id?: string
    vehicleId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutTripInput
    evaluation?: DriverEvaluationUncheckedCreateNestedOneWithoutTripInput
    metrics?: TripMetricUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutDriverInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput>
  }

  export type TripCreateManyDriverInputEnvelope = {
    data: TripCreateManyDriverInput | TripCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type AIRecommendationUpsertWithWhereUniqueWithoutDriverInput = {
    where: AIRecommendationWhereUniqueInput
    update: XOR<AIRecommendationUpdateWithoutDriverInput, AIRecommendationUncheckedUpdateWithoutDriverInput>
    create: XOR<AIRecommendationCreateWithoutDriverInput, AIRecommendationUncheckedCreateWithoutDriverInput>
  }

  export type AIRecommendationUpdateWithWhereUniqueWithoutDriverInput = {
    where: AIRecommendationWhereUniqueInput
    data: XOR<AIRecommendationUpdateWithoutDriverInput, AIRecommendationUncheckedUpdateWithoutDriverInput>
  }

  export type AIRecommendationUpdateManyWithWhereWithoutDriverInput = {
    where: AIRecommendationScalarWhereInput
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyWithoutDriverInput>
  }

  export type AIRecommendationScalarWhereInput = {
    AND?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
    OR?: AIRecommendationScalarWhereInput[]
    NOT?: AIRecommendationScalarWhereInput | AIRecommendationScalarWhereInput[]
    id?: StringFilter<"AIRecommendation"> | string
    targetType?: StringFilter<"AIRecommendation"> | string
    targetId?: StringFilter<"AIRecommendation"> | string
    recommendationType?: StringFilter<"AIRecommendation"> | string
    priority?: StringFilter<"AIRecommendation"> | string
    description?: StringFilter<"AIRecommendation"> | string
    suggestedAction?: StringFilter<"AIRecommendation"> | string
    metadata?: StringNullableFilter<"AIRecommendation"> | string | null
    createdAt?: DateTimeFilter<"AIRecommendation"> | Date | string
    driverId?: StringNullableFilter<"AIRecommendation"> | string | null
    vehicleId?: StringNullableFilter<"AIRecommendation"> | string | null
    componentId?: StringNullableFilter<"AIRecommendation"> | string | null
    tripId?: StringNullableFilter<"AIRecommendation"> | string | null
  }

  export type DriverEvaluationUpsertWithWhereUniqueWithoutDriverInput = {
    where: DriverEvaluationWhereUniqueInput
    update: XOR<DriverEvaluationUpdateWithoutDriverInput, DriverEvaluationUncheckedUpdateWithoutDriverInput>
    create: XOR<DriverEvaluationCreateWithoutDriverInput, DriverEvaluationUncheckedCreateWithoutDriverInput>
  }

  export type DriverEvaluationUpdateWithWhereUniqueWithoutDriverInput = {
    where: DriverEvaluationWhereUniqueInput
    data: XOR<DriverEvaluationUpdateWithoutDriverInput, DriverEvaluationUncheckedUpdateWithoutDriverInput>
  }

  export type DriverEvaluationUpdateManyWithWhereWithoutDriverInput = {
    where: DriverEvaluationScalarWhereInput
    data: XOR<DriverEvaluationUpdateManyMutationInput, DriverEvaluationUncheckedUpdateManyWithoutDriverInput>
  }

  export type DriverEvaluationScalarWhereInput = {
    AND?: DriverEvaluationScalarWhereInput | DriverEvaluationScalarWhereInput[]
    OR?: DriverEvaluationScalarWhereInput[]
    NOT?: DriverEvaluationScalarWhereInput | DriverEvaluationScalarWhereInput[]
    id?: StringFilter<"DriverEvaluation"> | string
    driverId?: StringFilter<"DriverEvaluation"> | string
    tripId?: StringFilter<"DriverEvaluation"> | string
    safetyScore?: FloatFilter<"DriverEvaluation"> | number
    fuelEfficiencyScore?: FloatFilter<"DriverEvaluation"> | number
    speedingInstances?: IntFilter<"DriverEvaluation"> | number
    hardBrakingCount?: IntFilter<"DriverEvaluation"> | number
    hardAccelerationCount?: IntFilter<"DriverEvaluation"> | number
    distractionScore?: FloatFilter<"DriverEvaluation"> | number
    overallScore?: FloatFilter<"DriverEvaluation"> | number
    recommendations?: StringNullableFilter<"DriverEvaluation"> | string | null
    createdAt?: DateTimeFilter<"DriverEvaluation"> | Date | string
  }

  export type DriverVehicleAssignmentUpsertWithWhereUniqueWithoutDriverInput = {
    where: DriverVehicleAssignmentWhereUniqueInput
    update: XOR<DriverVehicleAssignmentUpdateWithoutDriverInput, DriverVehicleAssignmentUncheckedUpdateWithoutDriverInput>
    create: XOR<DriverVehicleAssignmentCreateWithoutDriverInput, DriverVehicleAssignmentUncheckedCreateWithoutDriverInput>
  }

  export type DriverVehicleAssignmentUpdateWithWhereUniqueWithoutDriverInput = {
    where: DriverVehicleAssignmentWhereUniqueInput
    data: XOR<DriverVehicleAssignmentUpdateWithoutDriverInput, DriverVehicleAssignmentUncheckedUpdateWithoutDriverInput>
  }

  export type DriverVehicleAssignmentUpdateManyWithWhereWithoutDriverInput = {
    where: DriverVehicleAssignmentScalarWhereInput
    data: XOR<DriverVehicleAssignmentUpdateManyMutationInput, DriverVehicleAssignmentUncheckedUpdateManyWithoutDriverInput>
  }

  export type DriverVehicleAssignmentScalarWhereInput = {
    AND?: DriverVehicleAssignmentScalarWhereInput | DriverVehicleAssignmentScalarWhereInput[]
    OR?: DriverVehicleAssignmentScalarWhereInput[]
    NOT?: DriverVehicleAssignmentScalarWhereInput | DriverVehicleAssignmentScalarWhereInput[]
    driverId?: StringFilter<"DriverVehicleAssignment"> | string
    vehicleId?: StringFilter<"DriverVehicleAssignment"> | string
    assignedAt?: DateTimeFilter<"DriverVehicleAssignment"> | Date | string
  }

  export type UserUpsertWithoutDriverInput = {
    update: XOR<UserUpdateWithoutDriverInput, UserUncheckedUpdateWithoutDriverInput>
    create: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDriverInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDriverInput, UserUncheckedUpdateWithoutDriverInput>
  }

  export type UserUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TripUpsertWithWhereUniqueWithoutDriverInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutDriverInput, TripUncheckedUpdateWithoutDriverInput>
    create: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput>
  }

  export type TripUpdateWithWhereUniqueWithoutDriverInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutDriverInput, TripUncheckedUpdateWithoutDriverInput>
  }

  export type TripUpdateManyWithWhereWithoutDriverInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutDriverInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: StringFilter<"Trip"> | string
    vehicleId?: StringFilter<"Trip"> | string
    driverId?: StringFilter<"Trip"> | string
    startLocation?: StringNullableFilter<"Trip"> | string | null
    endLocation?: StringNullableFilter<"Trip"> | string | null
    startLatitude?: FloatNullableFilter<"Trip"> | number | null
    startLongitude?: FloatNullableFilter<"Trip"> | number | null
    endLatitude?: FloatNullableFilter<"Trip"> | number | null
    endLongitude?: FloatNullableFilter<"Trip"> | number | null
    startTime?: DateTimeFilter<"Trip"> | Date | string
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    distance?: FloatNullableFilter<"Trip"> | number | null
    fuelConsumed?: FloatNullableFilter<"Trip"> | number | null
    status?: StringFilter<"Trip"> | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
  }

  export type AIRecommendationCreateWithoutVehicleInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    component?: ComponentCreateNestedOneWithoutAiRecommendationsInput
    driver?: DriverCreateNestedOneWithoutAiRecommendationsInput
    trip?: TripCreateNestedOneWithoutAiRecommendationsInput
  }

  export type AIRecommendationUncheckedCreateWithoutVehicleInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driverId?: string | null
    componentId?: string | null
    tripId?: string | null
  }

  export type AIRecommendationCreateOrConnectWithoutVehicleInput = {
    where: AIRecommendationWhereUniqueInput
    create: XOR<AIRecommendationCreateWithoutVehicleInput, AIRecommendationUncheckedCreateWithoutVehicleInput>
  }

  export type AIRecommendationCreateManyVehicleInputEnvelope = {
    data: AIRecommendationCreateManyVehicleInput | AIRecommendationCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutVehicleInput = {
    id?: string
    type: string
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    component?: ComponentCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutVehicleInput = {
    id?: string
    type: string
    componentId?: string | null
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertCreateOrConnectWithoutVehicleInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutVehicleInput, AlertUncheckedCreateWithoutVehicleInput>
  }

  export type AlertCreateManyVehicleInputEnvelope = {
    data: AlertCreateManyVehicleInput | AlertCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type ComponentCreateWithoutVehicleInput = {
    id?: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutComponentInput
    alerts?: AlertCreateNestedManyWithoutComponentInput
    maintenance?: MaintenanceCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutVehicleInput = {
    id?: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutComponentInput
    alerts?: AlertUncheckedCreateNestedManyWithoutComponentInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutVehicleInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutVehicleInput, ComponentUncheckedCreateWithoutVehicleInput>
  }

  export type ComponentCreateManyVehicleInputEnvelope = {
    data: ComponentCreateManyVehicleInput | ComponentCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type DriverVehicleAssignmentCreateWithoutVehicleInput = {
    assignedAt?: Date | string
    driver: DriverCreateNestedOneWithoutAssignedVehiclesInput
  }

  export type DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput = {
    driverId: string
    assignedAt?: Date | string
  }

  export type DriverVehicleAssignmentCreateOrConnectWithoutVehicleInput = {
    where: DriverVehicleAssignmentWhereUniqueInput
    create: XOR<DriverVehicleAssignmentCreateWithoutVehicleInput, DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput>
  }

  export type DriverVehicleAssignmentCreateManyVehicleInputEnvelope = {
    data: DriverVehicleAssignmentCreateManyVehicleInput | DriverVehicleAssignmentCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceCreateWithoutVehicleInput = {
    id?: string
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    component?: ComponentCreateNestedOneWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateWithoutVehicleInput = {
    id?: string
    componentId?: string | null
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceCreateOrConnectWithoutVehicleInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutVehicleInput, MaintenanceUncheckedCreateWithoutVehicleInput>
  }

  export type MaintenanceCreateManyVehicleInputEnvelope = {
    data: MaintenanceCreateManyVehicleInput | MaintenanceCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type TripCreateWithoutVehicleInput = {
    id?: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutTripInput
    evaluation?: DriverEvaluationCreateNestedOneWithoutTripInput
    metrics?: TripMetricCreateNestedManyWithoutTripInput
    driver: DriverCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutVehicleInput = {
    id?: string
    driverId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutTripInput
    evaluation?: DriverEvaluationUncheckedCreateNestedOneWithoutTripInput
    metrics?: TripMetricUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutVehicleInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput>
  }

  export type TripCreateManyVehicleInputEnvelope = {
    data: TripCreateManyVehicleInput | TripCreateManyVehicleInput[]
    skipDuplicates?: boolean
  }

  export type AIRecommendationUpsertWithWhereUniqueWithoutVehicleInput = {
    where: AIRecommendationWhereUniqueInput
    update: XOR<AIRecommendationUpdateWithoutVehicleInput, AIRecommendationUncheckedUpdateWithoutVehicleInput>
    create: XOR<AIRecommendationCreateWithoutVehicleInput, AIRecommendationUncheckedCreateWithoutVehicleInput>
  }

  export type AIRecommendationUpdateWithWhereUniqueWithoutVehicleInput = {
    where: AIRecommendationWhereUniqueInput
    data: XOR<AIRecommendationUpdateWithoutVehicleInput, AIRecommendationUncheckedUpdateWithoutVehicleInput>
  }

  export type AIRecommendationUpdateManyWithWhereWithoutVehicleInput = {
    where: AIRecommendationScalarWhereInput
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyWithoutVehicleInput>
  }

  export type AlertUpsertWithWhereUniqueWithoutVehicleInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutVehicleInput, AlertUncheckedUpdateWithoutVehicleInput>
    create: XOR<AlertCreateWithoutVehicleInput, AlertUncheckedCreateWithoutVehicleInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutVehicleInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutVehicleInput, AlertUncheckedUpdateWithoutVehicleInput>
  }

  export type AlertUpdateManyWithWhereWithoutVehicleInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutVehicleInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    type?: StringFilter<"Alert"> | string
    vehicleId?: StringFilter<"Alert"> | string
    componentId?: StringNullableFilter<"Alert"> | string | null
    message?: StringFilter<"Alert"> | string
    actionRequired?: BoolFilter<"Alert"> | boolean
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
  }

  export type ComponentUpsertWithWhereUniqueWithoutVehicleInput = {
    where: ComponentWhereUniqueInput
    update: XOR<ComponentUpdateWithoutVehicleInput, ComponentUncheckedUpdateWithoutVehicleInput>
    create: XOR<ComponentCreateWithoutVehicleInput, ComponentUncheckedCreateWithoutVehicleInput>
  }

  export type ComponentUpdateWithWhereUniqueWithoutVehicleInput = {
    where: ComponentWhereUniqueInput
    data: XOR<ComponentUpdateWithoutVehicleInput, ComponentUncheckedUpdateWithoutVehicleInput>
  }

  export type ComponentUpdateManyWithWhereWithoutVehicleInput = {
    where: ComponentScalarWhereInput
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyWithoutVehicleInput>
  }

  export type ComponentScalarWhereInput = {
    AND?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    OR?: ComponentScalarWhereInput[]
    NOT?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    id?: StringFilter<"Component"> | string
    vehicleId?: StringFilter<"Component"> | string
    componentType?: StringFilter<"Component"> | string
    name?: StringFilter<"Component"> | string
    status?: StringFilter<"Component"> | string
    healthScore?: FloatFilter<"Component"> | number
    expectedLifespan?: IntFilter<"Component"> | number
    metadata?: StringNullableFilter<"Component"> | string | null
    createdAt?: DateTimeFilter<"Component"> | Date | string
    updatedAt?: DateTimeFilter<"Component"> | Date | string
  }

  export type DriverVehicleAssignmentUpsertWithWhereUniqueWithoutVehicleInput = {
    where: DriverVehicleAssignmentWhereUniqueInput
    update: XOR<DriverVehicleAssignmentUpdateWithoutVehicleInput, DriverVehicleAssignmentUncheckedUpdateWithoutVehicleInput>
    create: XOR<DriverVehicleAssignmentCreateWithoutVehicleInput, DriverVehicleAssignmentUncheckedCreateWithoutVehicleInput>
  }

  export type DriverVehicleAssignmentUpdateWithWhereUniqueWithoutVehicleInput = {
    where: DriverVehicleAssignmentWhereUniqueInput
    data: XOR<DriverVehicleAssignmentUpdateWithoutVehicleInput, DriverVehicleAssignmentUncheckedUpdateWithoutVehicleInput>
  }

  export type DriverVehicleAssignmentUpdateManyWithWhereWithoutVehicleInput = {
    where: DriverVehicleAssignmentScalarWhereInput
    data: XOR<DriverVehicleAssignmentUpdateManyMutationInput, DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleInput>
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutVehicleInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutVehicleInput, MaintenanceUncheckedUpdateWithoutVehicleInput>
    create: XOR<MaintenanceCreateWithoutVehicleInput, MaintenanceUncheckedCreateWithoutVehicleInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutVehicleInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutVehicleInput, MaintenanceUncheckedUpdateWithoutVehicleInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutVehicleInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutVehicleInput>
  }

  export type MaintenanceScalarWhereInput = {
    AND?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    OR?: MaintenanceScalarWhereInput[]
    NOT?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    vehicleId?: StringFilter<"Maintenance"> | string
    componentId?: StringNullableFilter<"Maintenance"> | string | null
    maintenanceType?: StringFilter<"Maintenance"> | string
    description?: StringFilter<"Maintenance"> | string
    metadata?: StringNullableFilter<"Maintenance"> | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
  }

  export type TripUpsertWithWhereUniqueWithoutVehicleInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutVehicleInput, TripUncheckedUpdateWithoutVehicleInput>
    create: XOR<TripCreateWithoutVehicleInput, TripUncheckedCreateWithoutVehicleInput>
  }

  export type TripUpdateWithWhereUniqueWithoutVehicleInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutVehicleInput, TripUncheckedUpdateWithoutVehicleInput>
  }

  export type TripUpdateManyWithWhereWithoutVehicleInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutVehicleInput>
  }

  export type DriverCreateWithoutAssignedVehiclesInput = {
    id?: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutDriverInput
    evaluations?: DriverEvaluationCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutAssignedVehiclesInput = {
    id?: string
    userId: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutDriverInput
    evaluations?: DriverEvaluationUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutAssignedVehiclesInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutAssignedVehiclesInput, DriverUncheckedCreateWithoutAssignedVehiclesInput>
  }

  export type VehicleCreateWithoutAssignedDriversInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutVehicleInput
    alerts?: AlertCreateNestedManyWithoutVehicleInput
    components?: ComponentCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceCreateNestedManyWithoutVehicleInput
    trips?: TripCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutAssignedDriversInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutVehicleInput
    alerts?: AlertUncheckedCreateNestedManyWithoutVehicleInput
    components?: ComponentUncheckedCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutVehicleInput
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutAssignedDriversInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutAssignedDriversInput, VehicleUncheckedCreateWithoutAssignedDriversInput>
  }

  export type DriverUpsertWithoutAssignedVehiclesInput = {
    update: XOR<DriverUpdateWithoutAssignedVehiclesInput, DriverUncheckedUpdateWithoutAssignedVehiclesInput>
    create: XOR<DriverCreateWithoutAssignedVehiclesInput, DriverUncheckedCreateWithoutAssignedVehiclesInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutAssignedVehiclesInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutAssignedVehiclesInput, DriverUncheckedUpdateWithoutAssignedVehiclesInput>
  }

  export type DriverUpdateWithoutAssignedVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutDriverNestedInput
    evaluations?: DriverEvaluationUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutAssignedVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutDriverNestedInput
    evaluations?: DriverEvaluationUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type VehicleUpsertWithoutAssignedDriversInput = {
    update: XOR<VehicleUpdateWithoutAssignedDriversInput, VehicleUncheckedUpdateWithoutAssignedDriversInput>
    create: XOR<VehicleCreateWithoutAssignedDriversInput, VehicleUncheckedCreateWithoutAssignedDriversInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutAssignedDriversInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutAssignedDriversInput, VehicleUncheckedUpdateWithoutAssignedDriversInput>
  }

  export type VehicleUpdateWithoutAssignedDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUpdateManyWithoutVehicleNestedInput
    components?: ComponentUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUpdateManyWithoutVehicleNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutAssignedDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutVehicleNestedInput
    components?: ComponentUncheckedUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutVehicleNestedInput
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type AIRecommendationCreateWithoutComponentInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driver?: DriverCreateNestedOneWithoutAiRecommendationsInput
    trip?: TripCreateNestedOneWithoutAiRecommendationsInput
    vehicle?: VehicleCreateNestedOneWithoutAiRecommendationsInput
  }

  export type AIRecommendationUncheckedCreateWithoutComponentInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driverId?: string | null
    vehicleId?: string | null
    tripId?: string | null
  }

  export type AIRecommendationCreateOrConnectWithoutComponentInput = {
    where: AIRecommendationWhereUniqueInput
    create: XOR<AIRecommendationCreateWithoutComponentInput, AIRecommendationUncheckedCreateWithoutComponentInput>
  }

  export type AIRecommendationCreateManyComponentInputEnvelope = {
    data: AIRecommendationCreateManyComponentInput | AIRecommendationCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutComponentInput = {
    id?: string
    type: string
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
    vehicle: VehicleCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutComponentInput = {
    id?: string
    type: string
    vehicleId: string
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertCreateOrConnectWithoutComponentInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutComponentInput, AlertUncheckedCreateWithoutComponentInput>
  }

  export type AlertCreateManyComponentInputEnvelope = {
    data: AlertCreateManyComponentInput | AlertCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type VehicleCreateWithoutComponentsInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutVehicleInput
    alerts?: AlertCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceCreateNestedManyWithoutVehicleInput
    trips?: TripCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutComponentsInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutVehicleInput
    alerts?: AlertUncheckedCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutVehicleInput
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutComponentsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutComponentsInput, VehicleUncheckedCreateWithoutComponentsInput>
  }

  export type MaintenanceCreateWithoutComponentInput = {
    id?: string
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateWithoutComponentInput = {
    id?: string
    vehicleId: string
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceCreateOrConnectWithoutComponentInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutComponentInput, MaintenanceUncheckedCreateWithoutComponentInput>
  }

  export type MaintenanceCreateManyComponentInputEnvelope = {
    data: MaintenanceCreateManyComponentInput | MaintenanceCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type AIRecommendationUpsertWithWhereUniqueWithoutComponentInput = {
    where: AIRecommendationWhereUniqueInput
    update: XOR<AIRecommendationUpdateWithoutComponentInput, AIRecommendationUncheckedUpdateWithoutComponentInput>
    create: XOR<AIRecommendationCreateWithoutComponentInput, AIRecommendationUncheckedCreateWithoutComponentInput>
  }

  export type AIRecommendationUpdateWithWhereUniqueWithoutComponentInput = {
    where: AIRecommendationWhereUniqueInput
    data: XOR<AIRecommendationUpdateWithoutComponentInput, AIRecommendationUncheckedUpdateWithoutComponentInput>
  }

  export type AIRecommendationUpdateManyWithWhereWithoutComponentInput = {
    where: AIRecommendationScalarWhereInput
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyWithoutComponentInput>
  }

  export type AlertUpsertWithWhereUniqueWithoutComponentInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutComponentInput, AlertUncheckedUpdateWithoutComponentInput>
    create: XOR<AlertCreateWithoutComponentInput, AlertUncheckedCreateWithoutComponentInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutComponentInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutComponentInput, AlertUncheckedUpdateWithoutComponentInput>
  }

  export type AlertUpdateManyWithWhereWithoutComponentInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutComponentInput>
  }

  export type VehicleUpsertWithoutComponentsInput = {
    update: XOR<VehicleUpdateWithoutComponentsInput, VehicleUncheckedUpdateWithoutComponentsInput>
    create: XOR<VehicleCreateWithoutComponentsInput, VehicleUncheckedCreateWithoutComponentsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutComponentsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutComponentsInput, VehicleUncheckedUpdateWithoutComponentsInput>
  }

  export type VehicleUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUpdateManyWithoutVehicleNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutVehicleNestedInput
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutComponentInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutComponentInput, MaintenanceUncheckedUpdateWithoutComponentInput>
    create: XOR<MaintenanceCreateWithoutComponentInput, MaintenanceUncheckedCreateWithoutComponentInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutComponentInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutComponentInput, MaintenanceUncheckedUpdateWithoutComponentInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutComponentInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutComponentInput>
  }

  export type AIRecommendationCreateWithoutTripInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    component?: ComponentCreateNestedOneWithoutAiRecommendationsInput
    driver?: DriverCreateNestedOneWithoutAiRecommendationsInput
    vehicle?: VehicleCreateNestedOneWithoutAiRecommendationsInput
  }

  export type AIRecommendationUncheckedCreateWithoutTripInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driverId?: string | null
    vehicleId?: string | null
    componentId?: string | null
  }

  export type AIRecommendationCreateOrConnectWithoutTripInput = {
    where: AIRecommendationWhereUniqueInput
    create: XOR<AIRecommendationCreateWithoutTripInput, AIRecommendationUncheckedCreateWithoutTripInput>
  }

  export type AIRecommendationCreateManyTripInputEnvelope = {
    data: AIRecommendationCreateManyTripInput | AIRecommendationCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type DriverEvaluationCreateWithoutTripInput = {
    id?: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations?: string | null
    createdAt?: Date | string
    driver: DriverCreateNestedOneWithoutEvaluationsInput
  }

  export type DriverEvaluationUncheckedCreateWithoutTripInput = {
    id?: string
    driverId: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations?: string | null
    createdAt?: Date | string
  }

  export type DriverEvaluationCreateOrConnectWithoutTripInput = {
    where: DriverEvaluationWhereUniqueInput
    create: XOR<DriverEvaluationCreateWithoutTripInput, DriverEvaluationUncheckedCreateWithoutTripInput>
  }

  export type TripMetricCreateWithoutTripInput = {
    id?: string
    speed?: number | null
    acceleration?: number | null
    braking?: number | null
    fuelConsumption?: number | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
  }

  export type TripMetricUncheckedCreateWithoutTripInput = {
    id?: string
    speed?: number | null
    acceleration?: number | null
    braking?: number | null
    fuelConsumption?: number | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
  }

  export type TripMetricCreateOrConnectWithoutTripInput = {
    where: TripMetricWhereUniqueInput
    create: XOR<TripMetricCreateWithoutTripInput, TripMetricUncheckedCreateWithoutTripInput>
  }

  export type TripMetricCreateManyTripInputEnvelope = {
    data: TripMetricCreateManyTripInput | TripMetricCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type DriverCreateWithoutTripsInput = {
    id?: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutDriverInput
    evaluations?: DriverEvaluationCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutTripsInput = {
    id?: string
    userId: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutDriverInput
    evaluations?: DriverEvaluationUncheckedCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutTripsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
  }

  export type VehicleCreateWithoutTripsInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutVehicleInput
    alerts?: AlertCreateNestedManyWithoutVehicleInput
    components?: ComponentCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutTripsInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutVehicleInput
    alerts?: AlertUncheckedCreateNestedManyWithoutVehicleInput
    components?: ComponentUncheckedCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutTripsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTripsInput, VehicleUncheckedCreateWithoutTripsInput>
  }

  export type AIRecommendationUpsertWithWhereUniqueWithoutTripInput = {
    where: AIRecommendationWhereUniqueInput
    update: XOR<AIRecommendationUpdateWithoutTripInput, AIRecommendationUncheckedUpdateWithoutTripInput>
    create: XOR<AIRecommendationCreateWithoutTripInput, AIRecommendationUncheckedCreateWithoutTripInput>
  }

  export type AIRecommendationUpdateWithWhereUniqueWithoutTripInput = {
    where: AIRecommendationWhereUniqueInput
    data: XOR<AIRecommendationUpdateWithoutTripInput, AIRecommendationUncheckedUpdateWithoutTripInput>
  }

  export type AIRecommendationUpdateManyWithWhereWithoutTripInput = {
    where: AIRecommendationScalarWhereInput
    data: XOR<AIRecommendationUpdateManyMutationInput, AIRecommendationUncheckedUpdateManyWithoutTripInput>
  }

  export type DriverEvaluationUpsertWithoutTripInput = {
    update: XOR<DriverEvaluationUpdateWithoutTripInput, DriverEvaluationUncheckedUpdateWithoutTripInput>
    create: XOR<DriverEvaluationCreateWithoutTripInput, DriverEvaluationUncheckedCreateWithoutTripInput>
    where?: DriverEvaluationWhereInput
  }

  export type DriverEvaluationUpdateToOneWithWhereWithoutTripInput = {
    where?: DriverEvaluationWhereInput
    data: XOR<DriverEvaluationUpdateWithoutTripInput, DriverEvaluationUncheckedUpdateWithoutTripInput>
  }

  export type DriverEvaluationUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type DriverEvaluationUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMetricUpsertWithWhereUniqueWithoutTripInput = {
    where: TripMetricWhereUniqueInput
    update: XOR<TripMetricUpdateWithoutTripInput, TripMetricUncheckedUpdateWithoutTripInput>
    create: XOR<TripMetricCreateWithoutTripInput, TripMetricUncheckedCreateWithoutTripInput>
  }

  export type TripMetricUpdateWithWhereUniqueWithoutTripInput = {
    where: TripMetricWhereUniqueInput
    data: XOR<TripMetricUpdateWithoutTripInput, TripMetricUncheckedUpdateWithoutTripInput>
  }

  export type TripMetricUpdateManyWithWhereWithoutTripInput = {
    where: TripMetricScalarWhereInput
    data: XOR<TripMetricUpdateManyMutationInput, TripMetricUncheckedUpdateManyWithoutTripInput>
  }

  export type TripMetricScalarWhereInput = {
    AND?: TripMetricScalarWhereInput | TripMetricScalarWhereInput[]
    OR?: TripMetricScalarWhereInput[]
    NOT?: TripMetricScalarWhereInput | TripMetricScalarWhereInput[]
    id?: StringFilter<"TripMetric"> | string
    tripId?: StringFilter<"TripMetric"> | string
    speed?: FloatNullableFilter<"TripMetric"> | number | null
    acceleration?: FloatNullableFilter<"TripMetric"> | number | null
    braking?: FloatNullableFilter<"TripMetric"> | number | null
    fuelConsumption?: FloatNullableFilter<"TripMetric"> | number | null
    latitude?: FloatNullableFilter<"TripMetric"> | number | null
    longitude?: FloatNullableFilter<"TripMetric"> | number | null
    createdAt?: DateTimeFilter<"TripMetric"> | Date | string
  }

  export type DriverUpsertWithoutTripsInput = {
    update: XOR<DriverUpdateWithoutTripsInput, DriverUncheckedUpdateWithoutTripsInput>
    create: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutTripsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutTripsInput, DriverUncheckedUpdateWithoutTripsInput>
  }

  export type DriverUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutDriverNestedInput
    evaluations?: DriverEvaluationUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutDriverNestedInput
    evaluations?: DriverEvaluationUncheckedUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type VehicleUpsertWithoutTripsInput = {
    update: XOR<VehicleUpdateWithoutTripsInput, VehicleUncheckedUpdateWithoutTripsInput>
    create: XOR<VehicleCreateWithoutTripsInput, VehicleUncheckedCreateWithoutTripsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutTripsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutTripsInput, VehicleUncheckedUpdateWithoutTripsInput>
  }

  export type VehicleUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUpdateManyWithoutVehicleNestedInput
    components?: ComponentUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutVehicleNestedInput
    components?: ComponentUncheckedUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type TripCreateWithoutMetricsInput = {
    id?: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutTripInput
    evaluation?: DriverEvaluationCreateNestedOneWithoutTripInput
    driver: DriverCreateNestedOneWithoutTripsInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutMetricsInput = {
    id?: string
    vehicleId: string
    driverId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutTripInput
    evaluation?: DriverEvaluationUncheckedCreateNestedOneWithoutTripInput
  }

  export type TripCreateOrConnectWithoutMetricsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutMetricsInput, TripUncheckedCreateWithoutMetricsInput>
  }

  export type TripUpsertWithoutMetricsInput = {
    update: XOR<TripUpdateWithoutMetricsInput, TripUncheckedUpdateWithoutMetricsInput>
    create: XOR<TripCreateWithoutMetricsInput, TripUncheckedCreateWithoutMetricsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutMetricsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutMetricsInput, TripUncheckedUpdateWithoutMetricsInput>
  }

  export type TripUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutTripNestedInput
    evaluation?: DriverEvaluationUpdateOneWithoutTripNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutTripNestedInput
    evaluation?: DriverEvaluationUncheckedUpdateOneWithoutTripNestedInput
  }

  export type DriverCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    userId: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutEvaluationsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutEvaluationsInput, DriverUncheckedCreateWithoutEvaluationsInput>
  }

  export type TripCreateWithoutEvaluationInput = {
    id?: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutTripInput
    metrics?: TripMetricCreateNestedManyWithoutTripInput
    driver: DriverCreateNestedOneWithoutTripsInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutEvaluationInput = {
    id?: string
    vehicleId: string
    driverId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutTripInput
    metrics?: TripMetricUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutEvaluationInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutEvaluationInput, TripUncheckedCreateWithoutEvaluationInput>
  }

  export type DriverUpsertWithoutEvaluationsInput = {
    update: XOR<DriverUpdateWithoutEvaluationsInput, DriverUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<DriverCreateWithoutEvaluationsInput, DriverUncheckedCreateWithoutEvaluationsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutEvaluationsInput, DriverUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DriverUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type TripUpsertWithoutEvaluationInput = {
    update: XOR<TripUpdateWithoutEvaluationInput, TripUncheckedUpdateWithoutEvaluationInput>
    create: XOR<TripCreateWithoutEvaluationInput, TripUncheckedCreateWithoutEvaluationInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutEvaluationInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutEvaluationInput, TripUncheckedUpdateWithoutEvaluationInput>
  }

  export type TripUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutTripNestedInput
    metrics?: TripMetricUpdateManyWithoutTripNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutTripNestedInput
    metrics?: TripMetricUncheckedUpdateManyWithoutTripNestedInput
  }

  export type ComponentCreateWithoutAlertsInput = {
    id?: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutComponentInput
    vehicle: VehicleCreateNestedOneWithoutComponentsInput
    maintenance?: MaintenanceCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutAlertsInput = {
    id?: string
    vehicleId: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutComponentInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutAlertsInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutAlertsInput, ComponentUncheckedCreateWithoutAlertsInput>
  }

  export type VehicleCreateWithoutAlertsInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutVehicleInput
    components?: ComponentCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceCreateNestedManyWithoutVehicleInput
    trips?: TripCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutAlertsInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutVehicleInput
    components?: ComponentUncheckedCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutVehicleInput
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutAlertsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutAlertsInput, VehicleUncheckedCreateWithoutAlertsInput>
  }

  export type ComponentUpsertWithoutAlertsInput = {
    update: XOR<ComponentUpdateWithoutAlertsInput, ComponentUncheckedUpdateWithoutAlertsInput>
    create: XOR<ComponentCreateWithoutAlertsInput, ComponentUncheckedCreateWithoutAlertsInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutAlertsInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutAlertsInput, ComponentUncheckedUpdateWithoutAlertsInput>
  }

  export type ComponentUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutComponentNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutComponentsNestedInput
    maintenance?: MaintenanceUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutComponentNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type VehicleUpsertWithoutAlertsInput = {
    update: XOR<VehicleUpdateWithoutAlertsInput, VehicleUncheckedUpdateWithoutAlertsInput>
    create: XOR<VehicleCreateWithoutAlertsInput, VehicleUncheckedCreateWithoutAlertsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutAlertsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutAlertsInput, VehicleUncheckedUpdateWithoutAlertsInput>
  }

  export type VehicleUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutVehicleNestedInput
    components?: ComponentUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUpdateManyWithoutVehicleNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutVehicleNestedInput
    components?: ComponentUncheckedUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutVehicleNestedInput
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type ComponentCreateWithoutMaintenanceInput = {
    id?: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutComponentInput
    alerts?: AlertCreateNestedManyWithoutComponentInput
    vehicle: VehicleCreateNestedOneWithoutComponentsInput
  }

  export type ComponentUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    vehicleId: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutComponentInput
    alerts?: AlertUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutMaintenanceInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutMaintenanceInput, ComponentUncheckedCreateWithoutMaintenanceInput>
  }

  export type VehicleCreateWithoutMaintenanceInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationCreateNestedManyWithoutVehicleInput
    alerts?: AlertCreateNestedManyWithoutVehicleInput
    components?: ComponentCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentCreateNestedManyWithoutVehicleInput
    trips?: TripCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    aiRecommendations?: AIRecommendationUncheckedCreateNestedManyWithoutVehicleInput
    alerts?: AlertUncheckedCreateNestedManyWithoutVehicleInput
    components?: ComponentUncheckedCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutVehicleInput
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutMaintenanceInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutMaintenanceInput, VehicleUncheckedCreateWithoutMaintenanceInput>
  }

  export type ComponentUpsertWithoutMaintenanceInput = {
    update: XOR<ComponentUpdateWithoutMaintenanceInput, ComponentUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<ComponentCreateWithoutMaintenanceInput, ComponentUncheckedCreateWithoutMaintenanceInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutMaintenanceInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutMaintenanceInput, ComponentUncheckedUpdateWithoutMaintenanceInput>
  }

  export type ComponentUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutComponentNestedInput
    alerts?: AlertUpdateManyWithoutComponentNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type ComponentUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutComponentNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type VehicleUpsertWithoutMaintenanceInput = {
    update: XOR<VehicleUpdateWithoutMaintenanceInput, VehicleUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<VehicleCreateWithoutMaintenanceInput, VehicleUncheckedCreateWithoutMaintenanceInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutMaintenanceInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutMaintenanceInput, VehicleUncheckedUpdateWithoutMaintenanceInput>
  }

  export type VehicleUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUpdateManyWithoutVehicleNestedInput
    components?: ComponentUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUpdateManyWithoutVehicleNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutVehicleNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutVehicleNestedInput
    components?: ComponentUncheckedUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleNestedInput
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type ComponentCreateWithoutAiRecommendationsInput = {
    id?: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutComponentInput
    vehicle: VehicleCreateNestedOneWithoutComponentsInput
    maintenance?: MaintenanceCreateNestedManyWithoutComponentInput
  }

  export type ComponentUncheckedCreateWithoutAiRecommendationsInput = {
    id?: string
    vehicleId: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutComponentInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutComponentInput
  }

  export type ComponentCreateOrConnectWithoutAiRecommendationsInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutAiRecommendationsInput, ComponentUncheckedCreateWithoutAiRecommendationsInput>
  }

  export type DriverCreateWithoutAiRecommendationsInput = {
    id?: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: DriverEvaluationCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentCreateNestedManyWithoutDriverInput
    user: UserCreateNestedOneWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutAiRecommendationsInput = {
    id?: string
    userId: string
    name: string
    licenseNumber: string
    licenseExpiry: Date | string
    phoneNumber: string
    driverScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: DriverEvaluationUncheckedCreateNestedManyWithoutDriverInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutAiRecommendationsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutAiRecommendationsInput, DriverUncheckedCreateWithoutAiRecommendationsInput>
  }

  export type TripCreateWithoutAiRecommendationsInput = {
    id?: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    evaluation?: DriverEvaluationCreateNestedOneWithoutTripInput
    metrics?: TripMetricCreateNestedManyWithoutTripInput
    driver: DriverCreateNestedOneWithoutTripsInput
    vehicle: VehicleCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutAiRecommendationsInput = {
    id?: string
    vehicleId: string
    driverId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
    evaluation?: DriverEvaluationUncheckedCreateNestedOneWithoutTripInput
    metrics?: TripMetricUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutAiRecommendationsInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutAiRecommendationsInput, TripUncheckedCreateWithoutAiRecommendationsInput>
  }

  export type VehicleCreateWithoutAiRecommendationsInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutVehicleInput
    components?: ComponentCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceCreateNestedManyWithoutVehicleInput
    trips?: TripCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutAiRecommendationsInput = {
    id?: string
    model: string
    year: number
    plateNumber: string
    status: string
    fuelType: string
    fuelLevel: number
    insuranceExpiry: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutVehicleInput
    components?: ComponentUncheckedCreateNestedManyWithoutVehicleInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedCreateNestedManyWithoutVehicleInput
    maintenance?: MaintenanceUncheckedCreateNestedManyWithoutVehicleInput
    trips?: TripUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutAiRecommendationsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutAiRecommendationsInput, VehicleUncheckedCreateWithoutAiRecommendationsInput>
  }

  export type ComponentUpsertWithoutAiRecommendationsInput = {
    update: XOR<ComponentUpdateWithoutAiRecommendationsInput, ComponentUncheckedUpdateWithoutAiRecommendationsInput>
    create: XOR<ComponentCreateWithoutAiRecommendationsInput, ComponentUncheckedCreateWithoutAiRecommendationsInput>
    where?: ComponentWhereInput
  }

  export type ComponentUpdateToOneWithWhereWithoutAiRecommendationsInput = {
    where?: ComponentWhereInput
    data: XOR<ComponentUpdateWithoutAiRecommendationsInput, ComponentUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type ComponentUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutComponentNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutComponentsNestedInput
    maintenance?: MaintenanceUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutComponentNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type DriverUpsertWithoutAiRecommendationsInput = {
    update: XOR<DriverUpdateWithoutAiRecommendationsInput, DriverUncheckedUpdateWithoutAiRecommendationsInput>
    create: XOR<DriverCreateWithoutAiRecommendationsInput, DriverUncheckedCreateWithoutAiRecommendationsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutAiRecommendationsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutAiRecommendationsInput, DriverUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type DriverUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: DriverEvaluationUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUpdateManyWithoutDriverNestedInput
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    driverScore?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: DriverEvaluationUncheckedUpdateManyWithoutDriverNestedInput
    assignedVehicles?: DriverVehicleAssignmentUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type TripUpsertWithoutAiRecommendationsInput = {
    update: XOR<TripUpdateWithoutAiRecommendationsInput, TripUncheckedUpdateWithoutAiRecommendationsInput>
    create: XOR<TripCreateWithoutAiRecommendationsInput, TripUncheckedCreateWithoutAiRecommendationsInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutAiRecommendationsInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutAiRecommendationsInput, TripUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type TripUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluation?: DriverEvaluationUpdateOneWithoutTripNestedInput
    metrics?: TripMetricUpdateManyWithoutTripNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluation?: DriverEvaluationUncheckedUpdateOneWithoutTripNestedInput
    metrics?: TripMetricUncheckedUpdateManyWithoutTripNestedInput
  }

  export type VehicleUpsertWithoutAiRecommendationsInput = {
    update: XOR<VehicleUpdateWithoutAiRecommendationsInput, VehicleUncheckedUpdateWithoutAiRecommendationsInput>
    create: XOR<VehicleCreateWithoutAiRecommendationsInput, VehicleUncheckedCreateWithoutAiRecommendationsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutAiRecommendationsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutAiRecommendationsInput, VehicleUncheckedUpdateWithoutAiRecommendationsInput>
  }

  export type VehicleUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutVehicleNestedInput
    components?: ComponentUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUpdateManyWithoutVehicleNestedInput
    trips?: TripUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutAiRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    fuelType?: StringFieldUpdateOperationsInput | string
    fuelLevel?: FloatFieldUpdateOperationsInput | number
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutVehicleNestedInput
    components?: ComponentUncheckedUpdateManyWithoutVehicleNestedInput
    assignedDrivers?: DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutVehicleNestedInput
    trips?: TripUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationCreateManyDriverInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    vehicleId?: string | null
    componentId?: string | null
    tripId?: string | null
  }

  export type DriverEvaluationCreateManyDriverInput = {
    id?: string
    tripId: string
    safetyScore: number
    fuelEfficiencyScore: number
    speedingInstances: number
    hardBrakingCount: number
    hardAccelerationCount: number
    distractionScore: number
    overallScore: number
    recommendations?: string | null
    createdAt?: Date | string
  }

  export type DriverVehicleAssignmentCreateManyDriverInput = {
    vehicleId: string
    assignedAt?: Date | string
  }

  export type TripCreateManyDriverInput = {
    id?: string
    vehicleId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
  }

  export type AIRecommendationUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: ComponentUpdateOneWithoutAiRecommendationsNestedInput
    trip?: TripUpdateOneWithoutAiRecommendationsNestedInput
    vehicle?: VehicleUpdateOneWithoutAiRecommendationsNestedInput
  }

  export type AIRecommendationUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIRecommendationUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DriverEvaluationUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trip?: TripUpdateOneRequiredWithoutEvaluationNestedInput
  }

  export type DriverEvaluationUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverEvaluationUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    safetyScore?: FloatFieldUpdateOperationsInput | number
    fuelEfficiencyScore?: FloatFieldUpdateOperationsInput | number
    speedingInstances?: IntFieldUpdateOperationsInput | number
    hardBrakingCount?: IntFieldUpdateOperationsInput | number
    hardAccelerationCount?: IntFieldUpdateOperationsInput | number
    distractionScore?: FloatFieldUpdateOperationsInput | number
    overallScore?: FloatFieldUpdateOperationsInput | number
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleAssignmentUpdateWithoutDriverInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutAssignedDriversNestedInput
  }

  export type DriverVehicleAssignmentUncheckedUpdateWithoutDriverInput = {
    vehicleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleAssignmentUncheckedUpdateManyWithoutDriverInput = {
    vehicleId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutTripNestedInput
    evaluation?: DriverEvaluationUpdateOneWithoutTripNestedInput
    metrics?: TripMetricUpdateManyWithoutTripNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutTripNestedInput
    evaluation?: DriverEvaluationUncheckedUpdateOneWithoutTripNestedInput
    metrics?: TripMetricUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationCreateManyVehicleInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driverId?: string | null
    componentId?: string | null
    tripId?: string | null
  }

  export type AlertCreateManyVehicleInput = {
    id?: string
    type: string
    componentId?: string | null
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type ComponentCreateManyVehicleInput = {
    id?: string
    componentType: string
    name: string
    status: string
    healthScore: number
    expectedLifespan: number
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverVehicleAssignmentCreateManyVehicleInput = {
    driverId: string
    assignedAt?: Date | string
  }

  export type MaintenanceCreateManyVehicleInput = {
    id?: string
    componentId?: string | null
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCreateManyVehicleInput = {
    id?: string
    driverId: string
    startLocation?: string | null
    endLocation?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    endLatitude?: number | null
    endLongitude?: number | null
    startTime: Date | string
    endTime?: Date | string | null
    distance?: number | null
    fuelConsumed?: number | null
    status: string
    updatedAt?: Date | string
  }

  export type AIRecommendationUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: ComponentUpdateOneWithoutAiRecommendationsNestedInput
    driver?: DriverUpdateOneWithoutAiRecommendationsNestedInput
    trip?: TripUpdateOneWithoutAiRecommendationsNestedInput
  }

  export type AIRecommendationUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIRecommendationUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    component?: ComponentUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComponentUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutComponentNestedInput
    alerts?: AlertUpdateManyWithoutComponentNestedInput
    maintenance?: MaintenanceUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutComponentNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutComponentNestedInput
    maintenance?: MaintenanceUncheckedUpdateManyWithoutComponentNestedInput
  }

  export type ComponentUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    healthScore?: FloatFieldUpdateOperationsInput | number
    expectedLifespan?: IntFieldUpdateOperationsInput | number
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleAssignmentUpdateWithoutVehicleInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutAssignedVehiclesNestedInput
  }

  export type DriverVehicleAssignmentUncheckedUpdateWithoutVehicleInput = {
    driverId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVehicleAssignmentUncheckedUpdateManyWithoutVehicleInput = {
    driverId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: ComponentUpdateOneWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUpdateManyWithoutTripNestedInput
    evaluation?: DriverEvaluationUpdateOneWithoutTripNestedInput
    metrics?: TripMetricUpdateManyWithoutTripNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiRecommendations?: AIRecommendationUncheckedUpdateManyWithoutTripNestedInput
    evaluation?: DriverEvaluationUncheckedUpdateOneWithoutTripNestedInput
    metrics?: TripMetricUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startLocation?: NullableStringFieldUpdateOperationsInput | string | null
    endLocation?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumed?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationCreateManyComponentInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driverId?: string | null
    vehicleId?: string | null
    tripId?: string | null
  }

  export type AlertCreateManyComponentInput = {
    id?: string
    type: string
    vehicleId: string
    message: string
    actionRequired: boolean
    createdAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type MaintenanceCreateManyComponentInput = {
    id?: string
    vehicleId: string
    maintenanceType: string
    description: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIRecommendationUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneWithoutAiRecommendationsNestedInput
    trip?: TripUpdateOneWithoutAiRecommendationsNestedInput
    vehicle?: VehicleUpdateOneWithoutAiRecommendationsNestedInput
  }

  export type AIRecommendationUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIRecommendationUncheckedUpdateManyWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tripId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AlertUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicle?: VehicleUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaintenanceUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateManyWithoutComponentInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    maintenanceType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIRecommendationCreateManyTripInput = {
    id?: string
    targetType: string
    targetId: string
    recommendationType: string
    priority: string
    description: string
    suggestedAction: string
    metadata?: string | null
    createdAt?: Date | string
    driverId?: string | null
    vehicleId?: string | null
    componentId?: string | null
  }

  export type TripMetricCreateManyTripInput = {
    id?: string
    speed?: number | null
    acceleration?: number | null
    braking?: number | null
    fuelConsumption?: number | null
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
  }

  export type AIRecommendationUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    component?: ComponentUpdateOneWithoutAiRecommendationsNestedInput
    driver?: DriverUpdateOneWithoutAiRecommendationsNestedInput
    vehicle?: VehicleUpdateOneWithoutAiRecommendationsNestedInput
  }

  export type AIRecommendationUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIRecommendationUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    recommendationType?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    suggestedAction?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    componentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TripMetricUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    braking?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumption?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMetricUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    braking?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumption?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripMetricUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    acceleration?: NullableFloatFieldUpdateOperationsInput | number | null
    braking?: NullableFloatFieldUpdateOperationsInput | number | null
    fuelConsumption?: NullableFloatFieldUpdateOperationsInput | number | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}